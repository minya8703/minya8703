# 🎯 한샘 면접 준비 완벽 가이드
## 민야령 | SAP EAI 통합 전문가

> **매일 읽고, 자신감을 키우세요!** 💪
> 
> 마지막 업데이트: 2025.11.26

---

# 📚 목차

1. [Spring 관련 질문](#1-spring-관련-질문)
2. [서버 관련 질문](#2-서버-관련-질문)
3. [DB 관리와 개선 관련 질문](#3-db-관리와-개선-관련-질문)
4. [소스 개선 (SOLID, 디자인패턴)](#4-소스-개선-solid-디자인패턴)
5. [한샘 관련 질문 & 역질문](#5-한샘-관련-질문--역질문)
6. [핵심 용어 사전](#6-핵심-용어-사전)
7. [🆕 DB 심화: 인덱스, 쿼리 최적화, Redis, DBMS 비교](#7-db-심화-인덱스-쿼리-최적화-redis-dbms-비교)
8. [🆕 백엔드 실무 필수 지식 (책 기반)](#8-백엔드-실무-필수-지식-책-기반)
9. [🆕 Java 핵심 개념](#9-java-핵심-개념)
10. [🆕 자료구조와 알고리즘](#10-자료구조와-알고리즘)

---

# 1. Spring 관련 질문

## Q1. Spring Framework와 Spring Boot의 차이점은 무엇인가요?

### 💡 모범 답변

```
Spring Framework는 자바 엔터프라이즈 개발을 위한 포괄적인 프레임워크이고,
Spring Boot는 Spring을 더 쉽게 사용할 수 있도록 만든 "스타터 키트"입니다.

[실제 경험 연결]
세금계산서 Solution 개발 시 Spring Boot를 선택한 이유가 바로 이것입니다.
- 자동 설정(Auto Configuration)으로 초기 세팅 시간 70% 단축
- 내장 톰캣으로 독립 실행 가능한 JAR 배포
- MSA 구조에서 각 서비스 독립 배포에 최적화

비유하자면, Spring Framework는 '레고 블록 세트'이고,
Spring Boot는 '조립 설명서가 포함된 레고 키트'입니다.
```

### 🔑 핵심 키워드
| 항목 | Spring Framework | Spring Boot |
|------|------------------|-------------|
| 설정 | XML 또는 Java Config 직접 작성 | 자동 설정 (Auto Configuration) |
| 서버 | 외부 WAS 필요 (Tomcat 별도 설치) | 내장 서버 (Embedded Tomcat) |
| 의존성 | 개별 라이브러리 버전 관리 필요 | Starter로 버전 자동 관리 |
| 배포 | WAR 파일 | JAR 파일 (독립 실행) |

---

## Q2. Spring IoC(Inversion of Control)와 DI(Dependency Injection)를 설명해주세요.

### 💡 모범 답변

```
IoC는 "제어의 역전"으로, 객체의 생성과 관리를 개발자가 아닌 프레임워크가 담당합니다.
DI는 IoC를 구현하는 방법으로, 필요한 의존성을 외부에서 주입받습니다.

[재미있는 비유 🍕]
피자집을 운영한다고 생각해보세요.
- 기존 방식: 직접 치즈 농장, 토마토 농장, 밀가루 공장을 운영
- IoC/DI 방식: 식재료 공급업체에서 재료를 "배달"받음

Spring Container가 식재료 공급업체 역할을 합니다!

[실제 코드 예시]
@Service
public class TaxInvoiceService {
    private final SapJcoConnector sapConnector;  // 주입받음
    private final HomeTaxClient homeTaxClient;   // 주입받음
    
    @Autowired  // 생성자 주입 (권장)
    public TaxInvoiceService(SapJcoConnector sapConnector, 
                             HomeTaxClient homeTaxClient) {
        this.sapConnector = sapConnector;
        this.homeTaxClient = homeTaxClient;
    }
}
```

### 🔑 DI 주입 방식 3가지

| 방식 | 코드 | 장단점 |
|------|------|--------|
| **생성자 주입** ⭐ | `@Autowired` 생성자 | 불변성 보장, 테스트 용이, **권장** |
| 세터 주입 | `@Autowired` setter | 선택적 의존성에 적합 |
| 필드 주입 | `@Autowired` 필드 | 간결하지만 테스트 어려움 |

---

## Q3. Spring AOP(Aspect-Oriented Programming)를 설명해주세요.

### 💡 모범 답변

```
AOP는 "관점 지향 프로그래밍"으로, 핵심 비즈니스 로직과 
공통 관심사(로깅, 트랜잭션, 보안)를 분리하는 기법입니다.

[재미있는 비유 🏠]
아파트를 생각해보세요.
- 핵심 로직 = 각 세대의 인테리어 (거주자가 직접 관리)
- 공통 관심사 = 경비, 청소, 엘리베이터 유지보수 (관리사무소가 일괄 관리)

AOP는 "관리사무소" 역할을 합니다!

[실제 프로젝트 적용 사례]
세금계산서 시스템에서 AOP 활용:
- @Transactional: SAP-홈택스 연동 시 트랜잭션 관리
- 로깅 Aspect: 모든 API 호출 이력 자동 기록
- 실행 시간 측정: 처리 시간 70% 단축 검증에 활용
```

### 🔑 AOP 핵심 용어

| 용어 | 설명 | 비유 |
|------|------|------|
| **Aspect** | 공통 관심사 모듈 | 관리사무소 업무 전체 |
| **Join Point** | Aspect 적용 가능 지점 | 경비원이 체크할 수 있는 모든 출입구 |
| **Pointcut** | 실제 적용할 Join Point 선택 | "정문만 체크하겠다" |
| **Advice** | 실제 수행할 동작 | Before, After, Around 등 |

---

## Q4. Spring Data JPA에서 N+1 문제와 해결방법을 설명해주세요.

### 💡 모범 답변

```
N+1 문제는 1개의 쿼리로 N개의 데이터를 가져온 후,
연관 데이터를 가져오기 위해 N개의 추가 쿼리가 발생하는 문제입니다.

[재미있는 비유 🍜]
라면 가게에서 손님 10명이 주문했는데,
- N+1 문제: 주방장이 라면 1개씩 10번 끓임 (비효율!)
- 해결 후: 큰 냄비에 10개 한번에 끓임 (효율적!)

[해결 방법 3가지]
1. Fetch Join
   @Query("SELECT o FROM Order o JOIN FETCH o.items")
   
2. EntityGraph
   @EntityGraph(attributePaths = {"items"})
   
3. Batch Size 설정
   @BatchSize(size = 100)  // 100개씩 IN 쿼리로 묶음

[실제 경험]
세금계산서 시스템에서 MariaDB 연동 시 Fetch Join 적용으로
쿼리 수 90% 감소, 응답 시간 개선
```

---

## Q5. @Transactional의 동작 원리와 전파 속성을 설명해주세요.

### 💡 모범 답변

```
@Transactional은 AOP 기반으로 동작하며, 
프록시 패턴을 통해 트랜잭션 시작/커밋/롤백을 자동 관리합니다.

[핵심 전파 속성(Propagation)]
1. REQUIRED (기본값): 있으면 참여, 없으면 새로 생성
2. REQUIRES_NEW: 항상 새 트랜잭션 생성 (기존 일시 중단)
3. NESTED: 중첩 트랜잭션 (부분 롤백 가능)

[실제 적용 사례 - 세금계산서 시스템]
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void issueInvoice(TaxInvoice invoice) {
    // SAP 데이터 조회
    // 홈택스 발행
    // 결과 저장
}

→ 이중 발행 오류 0건 달성의 핵심 요소!
```

### 🔑 @Transactional 주의사항

| 주의사항 | 설명 |
|---------|------|
| **같은 클래스 내부 호출** | 프록시를 거치지 않아 트랜잭션 미적용! |
| **private 메서드** | 프록시가 오버라이드 불가, 트랜잭션 미적용 |
| **Checked Exception** | 기본적으로 롤백 안 함 (rollbackFor 설정 필요) |
| **readOnly = true** | 읽기 전용으로 성능 최적화 |

---

# 2. 서버 관련 질문

## Q1. MSA(Microservices Architecture)를 설명하고, 경험을 말씀해주세요.

### 💡 모범 답변

```
MSA는 애플리케이션을 작고 독립적인 서비스들로 분리하여 
개발, 배포, 확장을 독립적으로 수행하는 아키텍처입니다.

[재미있는 비유 🏢]
- 모놀리식: 대형 백화점 (모든 매장이 한 건물)
  → 한 매장 리모델링하려면 전체 영업 중단
  
- MSA: 쇼핑몰 (각 매장이 독립 건물)
  → A매장 리모델링해도 B매장은 정상 영업

[실제 프로젝트 - 세금계산서 Solution]
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  JCo 서버   │────▶│  중계 서버   │────▶│  회계 Sol   │
│ (Port:8081) │     │ (Port:8082) │     │ (Port:8083) │
│  독립 DB    │     │  독립 DB    │     │  독립 DB    │
└─────────────┘     └─────────────┘     └─────────────┘

[달성 성과]
✅ 한 서비스 수정 시 다른 서비스 재시작 불필요
✅ 처리 시간 70% 단축 (5분 → 1.5분/건)
✅ 서비스 간 결합도 최소화
```

### 🔑 MSA vs 모놀리식 비교

| 항목 | 모놀리식 | MSA |
|------|----------|-----|
| 배포 | 전체 재배포 | 개별 서비스 배포 |
| 확장 | 전체 확장 | 필요한 서비스만 확장 |
| 장애 | 전체 서비스 중단 | 해당 서비스만 영향 |
| 기술 스택 | 동일 기술 | 서비스별 최적 기술 선택 가능 |
| 복잡도 | 낮음 | 높음 (분산 시스템) |

---

## Q2. REST API 설계 원칙과 Best Practice를 설명해주세요.

### 💡 모범 답변

```
REST는 자원(Resource)을 URI로 표현하고, 
HTTP 메서드로 행위를 정의하는 아키텍처 스타일입니다.

[RESTful URI 설계 원칙]
❌ Bad:  /getTaxInvoice, /createInvoice, /invoice/delete
✅ Good: /tax-invoices (복수형 명사)

[HTTP 메서드 활용]
GET    /tax-invoices          → 목록 조회
GET    /tax-invoices/{id}     → 단건 조회
POST   /tax-invoices          → 생성
PUT    /tax-invoices/{id}     → 전체 수정
PATCH  /tax-invoices/{id}     → 부분 수정
DELETE /tax-invoices/{id}     → 삭제

[실제 프로젝트 적용]
세금계산서 시스템에서 RESTful API 기반 JSON 통신 구현:
- 표준화된 응답 형식: { "code": 200, "data": {...}, "message": "" }
- SAP-홈택스 실시간 연동으로 이중 발행 오류 0건 달성
```

### 🔑 HTTP 상태 코드

| 코드 | 의미 | 사용 예시 |
|------|------|----------|
| **200** | OK | 조회 성공 |
| **201** | Created | 생성 성공 |
| **204** | No Content | 삭제 성공 |
| **400** | Bad Request | 잘못된 요청 파라미터 |
| **401** | Unauthorized | 인증 필요 |
| **403** | Forbidden | 권한 없음 |
| **404** | Not Found | 리소스 없음 |
| **500** | Internal Server Error | 서버 오류 |

---

## Q3. 로드 밸런싱(Load Balancing)이란 무엇인가요?

### 💡 모범 답변

```
로드 밸런싱은 여러 서버에 트래픽을 분산하여 
시스템의 가용성과 응답 속도를 높이는 기술입니다.

[재미있는 비유 🎰]
놀이공원 입장 게이트를 생각해보세요.
- 게이트 1개: 손님 1000명이 줄 서서 기다림 😫
- 게이트 10개: 각 게이트에 100명씩 분산 → 빠른 입장! 😊

로드 밸런서 = 손님을 각 게이트로 안내하는 안내원

[로드 밸런싱 알고리즘]
1. Round Robin: 순서대로 분배 (기본)
2. Least Connections: 연결 수 적은 서버로 분배
3. IP Hash: 같은 IP는 같은 서버로 (세션 유지)
4. Weighted: 서버 성능에 따라 가중치 분배

[MSA 환경에서의 경험]
세금계산서 시스템에서 각 서비스 독립 포트/IP 할당 시
향후 로드 밸런싱 확장을 고려한 설계 적용
```

---

## Q4. 세션(Session)과 JWT의 차이점은 무엇인가요?

### 💡 모범 답변

```
[세션 기반 인증]
- 서버에 사용자 상태 저장
- 세션 ID만 클라이언트에 전달
- 서버 메모리/DB 사용

[JWT(JSON Web Token) 기반 인증]
- 클라이언트에 토큰(정보+서명) 저장
- 서버는 상태를 저장하지 않음 (Stateless)
- 토큰 자체에 정보 포함

[재미있는 비유 🎫]
- 세션: 호텔 프론트에서 방 키 받고, 체크아웃 때까지 호텔이 관리
- JWT: 놀이공원 자유이용권, 팔찌에 모든 정보가 있어서 
       어느 놀이기구든 팔찌만 보여주면 OK!

[MFA 시스템 개발 경험 연결]
일본 증권사 MFA 시스템 개발 시 세션 기반 + SMS 인증 조합
→ 부정 로그인 30% 감소, SMS 발송 성공률 99.2%
```

### 🔑 세션 vs JWT 비교

| 항목 | 세션 | JWT |
|------|------|-----|
| 저장 위치 | 서버 | 클라이언트 |
| 확장성 | 서버 간 세션 공유 필요 | Stateless로 확장 용이 |
| 보안 | 서버에서 관리 | 토큰 탈취 시 위험 |
| 크기 | 세션 ID만 전송 (작음) | 토큰 전체 전송 (큼) |
| MSA 적합성 | 불리 | 유리 ⭐ |

---

## Q5. 서버 장애 대응 경험을 말씀해주세요.

### 💡 모범 답변

```
[규슈 전력 프로젝트 - 금융기관 연동 비정상 종료 대응]

[상황]
외부 금융기관 API 연동 시 간헐적 타임아웃 발생으로 
시스템 비정상 종료 빈발

[조치]
1. 문제 분석: 로그 분석으로 타임아웃 패턴 파악
2. 해결책 적용:
   - Connection Timeout / Read Timeout 분리 설정
   - Retry 로직 구현 (지수 백오프 적용)
   - Circuit Breaker 패턴 검토
3. 모니터링 강화: 응답 시간 임계치 알림 설정

[성과]
✅ 외부 금융기관 연동 오류 90% 감소
✅ 테스트 커버리지 100% 달성
✅ 요금 계산 정확도 100%

[현재 한샘에서의 적용]
webMethods EAI 기반 지속적 모니터링으로 선제적 장애 대응
→ 장애 발생률 감소
```

---

# 3. DB 관리와 개선 관련 질문

## Q1. 인덱스(Index)란 무엇이고, 언제 사용하나요?

### 💡 모범 답변

```
인덱스는 데이터베이스 검색 속도를 높이기 위한 자료구조로,
책의 '목차' 또는 '색인'과 같은 역할을 합니다.

[재미있는 비유 📚]
500페이지 책에서 "Spring Boot"를 찾으려면:
- 인덱스 없음: 1페이지부터 500페이지까지 전부 확인 😫
- 인덱스 있음: 목차에서 "S" 찾고 바로 해당 페이지로! 😊

[인덱스 사용하면 좋은 경우]
✅ WHERE 절에 자주 사용되는 컬럼
✅ JOIN에 사용되는 컬럼
✅ ORDER BY에 사용되는 컬럼
✅ 카디널리티(중복도)가 높은 컬럼

[인덱스 사용하면 안 좋은 경우]
❌ 데이터가 적은 테이블 (Full Scan이 더 빠름)
❌ INSERT/UPDATE/DELETE가 빈번한 컬럼
❌ 카디널리티가 낮은 컬럼 (성별 등)

[실제 경험 - Credit Saison 프로젝트]
2,500만 명 사용자 데이터 마이그레이션 시 적절한 인덱스 설계로
데이터 정합성 100% 달성
```

### 🔑 인덱스 종류

| 종류 | 설명 | 특징 |
|------|------|------|
| **B-Tree** | 가장 일반적인 인덱스 | 범위 검색에 효율적 |
| **Hash** | 해시 테이블 기반 | 동등 비교(=)에 최적 |
| **Composite** | 복합 인덱스 | 여러 컬럼 조합 |
| **Covering** | 커버링 인덱스 | 인덱스만으로 쿼리 완료 |

---

## Q2. SQL 쿼리 성능 최적화 경험을 말씀해주세요.

### 💡 모범 답변

```
[Usami Koyu 정유 기업 프로젝트]

[문제 상황]
- 회원 관리 쿼리 실행 시간 5초 이상
- 상품 관리 조인 시 풀 스캔 발생

[분석 방법]
EXPLAIN PLAN으로 실행 계획 분석
→ 인덱스 미사용, Nested Loop 비효율 발견

[최적화 방법]
1. 인덱스 추가
   CREATE INDEX idx_member_status ON member(status, created_date);

2. 쿼리 리팩터링
   - SELECT * → 필요한 컬럼만 명시
   - 서브쿼리 → JOIN으로 변환
   - OR 조건 → UNION으로 분리

3. 실행 계획 기반 힌트 추가

[성과]
✅ SQL 성능 분석 노하우 팀 내 공유
✅ 재사용 가능한 MyBatis Mapper 설계
✅ 팀 내 데이터베이스 설계 의사결정 지원
```

### 🔑 SQL 최적화 체크리스트

| 항목 | Bad | Good |
|------|-----|------|
| SELECT | SELECT * | SELECT id, name, email |
| 인덱스 활용 | LIKE '%검색어%' | LIKE '검색어%' |
| NULL 비교 | WHERE col = NULL | WHERE col IS NULL |
| IN vs EXISTS | 서브쿼리가 크면 IN | 서브쿼리가 크면 EXISTS |
| OR 조건 | WHERE a=1 OR b=2 | UNION 활용 검토 |

---

## Q3. 데이터 마이그레이션 경험을 말씀해주세요.

### 💡 모범 답변

```
[Credit Saison 프로젝트 - 일본 최대 신용카드사]

[규모]
- 사용자 약 2,500만 명
- 지급 관련 데이터 + 연체자 데이터 통합

[기술 스택]
- Informatica PowerCenter ETL
- Oracle DBMS
- Linux 환경

[마이그레이션 전략]
1. 데이터 정합성 검증 스크립트 작성
2. 단계별 마이그레이션 (Incremental)
3. 롤백 계획 수립
4. 실제 데이터와 유사한 테스트 데이터 구성

[성과]
✅ 대용량 데이터 마이그레이션 장애 0건
✅ 데이터 정합성 100% 달성
✅ 안정성 중심 아키텍처로 완료

[배운 점]
데이터 마이그레이션은 "기술"보다 "계획"이 중요합니다.
충분한 테스트와 롤백 전략이 성공의 핵심!
```

---

## Q4. 트랜잭션 격리 수준(Isolation Level)을 설명해주세요.

### 💡 모범 답변

```
트랜잭션 격리 수준은 동시에 여러 트랜잭션이 실행될 때 
데이터 일관성을 어느 정도 보장할지 정하는 수준입니다.

[재미있는 비유 🏦]
은행 ATM 2대가 동시에 내 통장을 조회할 때:
- 격리 수준 낮음: A ATM이 수정 중인 잔액을 B ATM이 볼 수 있음 (위험!)
- 격리 수준 높음: A ATM 작업 완료 전까지 B ATM 대기 (안전!)

[4가지 격리 수준]
1. READ UNCOMMITTED: 커밋 전 데이터 읽기 가능 (Dirty Read 발생)
2. READ COMMITTED: 커밋된 데이터만 읽기 (Oracle 기본값)
3. REPEATABLE READ: 같은 트랜잭션 내 동일 결과 보장 (MySQL 기본값)
4. SERIALIZABLE: 완전 직렬화 (성능 저하)

[세금계산서 시스템 적용]
이중 발행 방지를 위해 적절한 격리 수준 + 낙관적 락 조합
→ 이중 발행 오류 0건 달성
```

### 🔑 격리 수준별 문제 현상

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
|-----------|------------|---------------------|--------------|
| READ UNCOMMITTED | ⭕ 발생 | ⭕ 발생 | ⭕ 발생 |
| READ COMMITTED | ❌ 방지 | ⭕ 발생 | ⭕ 발생 |
| REPEATABLE READ | ❌ 방지 | ❌ 방지 | ⭕ 발생 |
| SERIALIZABLE | ❌ 방지 | ❌ 방지 | ❌ 방지 |

---

## Q5. 데이터베이스 정규화와 반정규화를 설명해주세요.

### 💡 모범 답변

```
[정규화 (Normalization)]
데이터 중복을 제거하고 무결성을 확보하는 과정

[재미있는 비유 📦]
이사할 때 짐 정리를 생각해보세요.
- 정규화: 같은 종류끼리 분류 (옷은 옷 상자, 책은 책 상자)
  → 찾기 쉽고 관리하기 좋음
- 반정규화: 자주 쓰는 물건은 한 상자에 몰아넣음
  → 꺼내기는 빠르지만 관리가 어려움

[정규화 단계]
1NF: 원자값 보장 (컬럼에 하나의 값만)
2NF: 완전 함수 종속 (부분 종속 제거)
3NF: 이행 종속 제거

[반정규화를 적용하는 경우]
- 조회 성능이 중요한 경우
- 조인 비용이 큰 경우
- 대시보드, 리포트 테이블

[실제 경험]
Yokogawa 렌털 시스템에서 데이터 구조 개선 시
정규화 원칙을 지키되, 조회가 많은 테이블은 반정규화 적용
```

---

# 4. 소스 개선 (SOLID, 디자인패턴)

## Q1. SOLID 원칙을 설명하고 실제 적용 경험을 말씀해주세요.

### 💡 모범 답변

```
SOLID는 객체지향 설계의 5가지 핵심 원칙입니다.

[S - Single Responsibility Principle (단일 책임 원칙)]
"한 클래스는 하나의 책임만 가져야 한다"

[재미있는 비유 🍳]
주방에서:
❌ 요리사가 요리도 하고, 설거지도 하고, 서빙도 하고, 계산도 함
✅ 요리사는 요리만, 홀 직원은 서빙만, 캐셔는 계산만

[실제 적용 - 세금계산서 시스템]
// Before: 모든 것을 처리하는 God Class
class TaxInvoiceManager {
    void fetchFromSap() {...}
    void sendToHomeTax() {...}
    void saveToDatabase() {...}
    void sendEmail() {...}
}

// After: 책임 분리
class SapDataFetcher { void fetch() {...} }
class HomeTaxSender { void send() {...} }
class InvoiceRepository { void save() {...} }
class EmailNotifier { void notify() {...} }
```

### 🔑 SOLID 전체 정리

| 원칙 | 설명 | 비유 |
|------|------|------|
| **S**RP | 단일 책임 | 요리사는 요리만! |
| **O**CP | 개방-폐쇄 | 콘센트에 어댑터 추가 (원본 수정 X) |
| **L**SP | 리스코프 치환 | 전기차도 '차'처럼 운전 가능해야 |
| **I**SP | 인터페이스 분리 | 리모컨 버튼은 필요한 것만 |
| **D**IP | 의존성 역전 | 구체 클래스가 아닌 인터페이스에 의존 |

---

## Q2. 디자인 패턴 중 프로젝트에서 사용한 경험을 말씀해주세요.

### 💡 모범 답변

```
[1. Strategy Pattern - 세금계산서 발행 방식]

[상황]
홈택스 직접 발행 / 대행사 위탁 발행 / 수동 발행 등 
발행 방식이 다양하게 존재

[적용]
interface TaxInvoiceIssuer {
    void issue(TaxInvoice invoice);
}

class HomeTaxDirectIssuer implements TaxInvoiceIssuer {...}
class AgencyDelegateIssuer implements TaxInvoiceIssuer {...}
class ManualIssuer implements TaxInvoiceIssuer {...}

// 런타임에 전략 교체 가능
issuerContext.setIssuer(new HomeTaxDirectIssuer());

[효과]
새로운 발행 방식 추가 시 기존 코드 수정 없이 확장 가능 (OCP)


[2. Template Method Pattern - ANA 항공 티켓 발권]

[상황]
발권 프로세스는 동일하나 항공권 종류별로 세부 로직이 다름

[적용]
abstract class TicketIssuanceTemplate {
    public final void issue() {  // 템플릿 메서드
        validate();
        calculatePrice();  // 훅 메서드
        generateTicket();
        sendNotification();
    }
    
    abstract void calculatePrice();  // 서브클래스에서 구현
}

[효과]
코드 중복 제거, 일관된 프로세스 보장
```

### 🔑 자주 사용되는 디자인 패턴

| 패턴 | 목적 | 실제 사용 예 |
|------|------|-------------|
| **Strategy** | 알고리즘 캡슐화 | 결제 방식, 발행 방식 |
| **Template Method** | 알고리즘 골격 정의 | 발권 프로세스 |
| **Factory** | 객체 생성 캡슐화 | DB 커넥션 생성 |
| **Singleton** | 인스턴스 하나 보장 | 설정 정보 관리 |
| **Observer** | 상태 변화 알림 | 이벤트 처리 |
| **Adapter** | 인터페이스 변환 | 레거시 시스템 연동 |

---

## Q3. 코드 리팩터링 경험을 말씀해주세요.

### 💡 모범 답변

```
[ANA 항공 프로젝트 - 레거시 코드 리팩터링]

[Before]
- 평균 메서드 200줄 😱
- 중단된 프로젝트 (진행률 20%)
- 테스트 코드 0개

[리팩터링 전략]
1. 테스트 코드 먼저 작성 (안전망 구축)
2. 메서드 추출 (Extract Method)
3. 의미 있는 이름으로 변경 (Rename)
4. 조건문 분해 (Decompose Conditional)

[After]
// Before: 200줄짜리 모놀리식 메서드
public void processTicket() {
    // 유효성 검사 50줄
    // 가격 계산 80줄
    // 발권 처리 70줄
}

// After: 명확하게 분리된 메서드
public void processTicket() {
    validate();           // 15줄
    Price price = calculatePrice();  // 20줄
    Ticket ticket = issue(price);    // 15줄
    notify(ticket);       // 10줄
}

[성과]
✅ 평균 메서드 200줄 → 30줄
✅ 프로젝트 진행률 20% → 100% (2개월)
✅ 단위 테스트 358개 작성
✅ 테스트 커버리지 80% 이상 달성
```

---

## Q4. 클린 코드의 원칙을 설명해주세요.

### 💡 모범 답변

```
클린 코드는 "읽기 쉽고, 이해하기 쉽고, 수정하기 쉬운" 코드입니다.

[핵심 원칙들]

1️⃣ 의미 있는 이름 사용
❌ int d;  // 경과 시간 (일)
✅ int elapsedTimeInDays;

2️⃣ 함수는 한 가지 일만
❌ saveAndSendEmailAndLog()
✅ save(), sendEmail(), log() 분리

3️⃣ 주석보다 코드로 설명
❌ // 사용자가 관리자인지 확인
   if (user.getType() == 1)
✅ if (user.isAdmin())

4️⃣ 에러 처리는 비즈니스 로직과 분리
try {
    processInvoice();
} catch (SapConnectionException e) {
    handleSapError(e);
} catch (HomeTaxException e) {
    handleHomeTaxError(e);
}

[ANA 항공 프로젝트에서 적용 후]
코드 가독성 크게 향상 → 신규 팀원 온보딩 시간 단축
```

---

## Q5. 코드 리뷰에서 중요하게 보는 점은 무엇인가요?

### 💡 모범 답변

```
[코드 리뷰 체크리스트]

1️⃣ 가독성 (Readability)
- 변수명/함수명이 의도를 명확히 표현하는가?
- 복잡한 로직에 주석이 있는가?

2️⃣ 테스트 가능성 (Testability)
- 의존성 주입이 되어 있는가?
- 단위 테스트 작성이 쉬운 구조인가?

3️⃣ 에러 처리 (Error Handling)
- 예외 상황을 적절히 처리하는가?
- 로깅이 충분한가?

4️⃣ 성능 (Performance)
- N+1 문제가 없는가?
- 불필요한 데이터 조회가 없는가?

5️⃣ 보안 (Security)
- SQL Injection 가능성은 없는가?
- 민감 정보 노출은 없는가?

[실제 경험]
일본에서 10년간 팀 협업 경험으로 
건설적인 피드백과 명확한 커뮤니케이션의 중요성 체득

"비판이 아닌 개선 제안"을 항상 염두
```

---

# 5. 한샘 관련 질문 & 역질문

## 🏢 한샘 기업 현황 (2025년 기준)

```
📊 핵심 수치
- 매출: 약 1조 9,084억원 (2024년 연결 기준)
- 영업이익: 312억원 (전년 대비 약 16배 증가!)
- 직원 수: 약 1,961명
- 업계 순위: 국내 홈 인테리어 1위 🏆

📈 최근 동향
- 9분기 연속 흑자 달성 (2023년 2분기 이후)
- ESG A등급 획득 (한국ESG기준원)
- 공정거래협약 이행평가 최우수 등급 (가구제조업 최초)
- 32년 만에 BI(Brand Identity) 개편

🎯 사업 구조
- B2C (58%): 리하우스/홈퍼니싱 아이템
- B2B (42%): 건설사 특판 및 자재판매
```

---

## Q1. 한샘에 지원한 동기가 무엇인가요?

### 💡 모범 답변

```
세 가지 이유로 한샘에 지원했습니다.

1️⃣ 기술적 시너지
현재 한샘에서 webMethods EAI 기반 SAP 연동 업무를 수행하고 있습니다.
50개 이상의 인터페이스 개발 경험과 MSA 아키텍처 구축 경험을
한샘의 디지털 전환 목표와 결합하고 싶습니다.

2️⃣ 도전적인 비즈니스 환경
건설 경기 침체 속에서도 9분기 연속 흑자를 달성하고,
영업이익 16배 성장을 이끌어낸 한샘의 저력에 매력을 느꼈습니다.
이러한 환경에서 IT 시스템의 역할이 더욱 중요해질 것이라 생각합니다.

3️⃣ 성장 가능성
한샘의 "토탈 홈 인테리어 전문기업"으로서의 비전과
디지털 플랫폼 확장 전략에 기여하고 싶습니다.
제 ERP/EAI 통합 역량으로 B2C/B2B 시스템 간 
효율적인 데이터 흐름을 구축하겠습니다.
```

---

## Q2. 한샘의 디지털 전환에 어떻게 기여할 수 있을까요?

### 💡 모범 답변

```
제 경험을 바탕으로 세 가지 영역에서 기여할 수 있습니다.

1️⃣ EAI 시스템 고도화
- 현재 운영 중인 webMethods 기반 50개+ 인터페이스 경험 활용
- 실시간 데이터 연동 품질 향상
- 장애 발생률 감소를 위한 선제적 모니터링 체계 강화

2️⃣ MSA 기반 시스템 현대화
- 세금계산서 시스템에서 검증한 MSA 아키텍처 적용
- 서비스 독립 배포로 릴리스 속도 향상
- 처리 시간 단축 (현재 경험: 70% 단축)

3️⃣ 온라인 플랫폼과 ERP 연동 최적화
- 한샘몰, 롯데하이마트 등 옴니채널 통합 데이터 관리
- 재고, 주문, 배송 시스템 간 실시간 동기화
- 고객 경험 향상을 위한 데이터 기반 의사결정 지원
```

---

## Q3. 한샘이 처한 도전 과제를 어떻게 생각하시나요?

### 💡 모범 답변

```
한샘이 직면한 도전을 이렇게 분석합니다:

[도전 과제]
1. 부동산/건설 경기 침체로 B2B 매출 압박
2. 온라인 가구 시장에서 경쟁 심화
3. 디지털 전환 가속화 필요

[IT 관점의 해결 방향]
1️⃣ B2C 강화를 위한 데이터 기반 의사결정
- 고객 행동 데이터 분석
- 재고 최적화로 원가율 개선 지원
- 개인화 추천 시스템 연동

2️⃣ 옴니채널 통합
- 오프라인 매장 + 온라인 몰 + 롯데 제휴 채널 통합
- 일관된 고객 경험을 위한 백엔드 시스템 연동
- 실시간 재고/배송 정보 동기화

3️⃣ 운영 효율화
- EAI 기반 자동화로 인력 업무 부담 감소
- 프로세스 자동화로 비용 절감

"위기는 기회"라는 말처럼, 
IT 시스템 고도화가 한샘의 경쟁력 강화에 핵심이 될 것입니다.
```

---

## Q4. 한샘에서 5년 후 어떤 모습이 되고 싶으신가요?

### 💡 모범 답변

```
단계별 성장 계획을 가지고 있습니다.

[1-2년: 기술 전문가]
- 한샘 시스템 전반에 대한 깊은 이해
- SAP/EAI 연동 안정화 및 성능 최적화
- 신규 인터페이스 개발 및 표준화 기여

[3-4년: 아키텍트]
- 시스템 아키텍처 설계 참여
- 디지털 전환 프로젝트 기술 리드
- 주니어 개발자 멘토링

[5년: 기술 리더]
- 한샘 IT 시스템 전략 수립 참여
- 기술 의사결정에 핵심 역할
- 비즈니스 가치 창출에 직접 기여

[개인적 목표]
"한샘의 모든 데이터가 원활하게 흐르는 시스템"을 
설계하고 운영하는 전문가가 되고 싶습니다.
```

---

## 🙋 면접관에게 할 역질문

### 💡 팀원/동료에게 할 질문

```
1. "현재 팀에서 가장 도전적인 기술적 과제는 무엇인가요?"
   → 실제 업무 환경과 기술 스택 파악

2. "SAP와 webMethods 외에 다른 EAI 솔루션 도입 계획이 있나요?"
   → 기술 로드맵과 변화 가능성 확인

3. "팀 내 코드 리뷰 문화는 어떻게 운영되고 있나요?"
   → 협업 문화와 개발 프로세스 파악

4. "신규 입사자 온보딩은 어떤 방식으로 진행되나요?"
   → 성장 지원 환경 확인

5. "가장 최근에 해결한 흥미로운 기술적 문제는 무엇이었나요?"
   → 실제 업무 경험과 문제 해결 문화 이해
```

### 💡 임원/리더에게 할 질문

```
1. "한샘 IT 조직의 향후 3년 비전은 무엇인가요?"
   → 전략적 방향성과 투자 계획 파악

2. "디지털 전환에서 IT 팀의 역할을 어떻게 정의하시나요?"
   → IT의 비즈니스 기여도 기대치 확인

3. "한샘에서 성공적인 개발자의 특징은 무엇이라고 생각하시나요?"
   → 조직 문화와 인재상 이해

4. "B2C 온라인 사업 확대에서 IT 시스템의 역할을 어떻게 보시나요?"
   → 비즈니스와 IT 연계 전략 파악

5. "최근 '한샘다움' 제정 등 조직 문화 혁신을 진행 중인데, 
   개발 조직에는 어떤 변화가 있나요?"
   → 조직 문화와 일하는 방식 변화 파악
```

---

# 6. 핵심 용어 사전

## 🏗️ 아키텍처 용어

### EAI (Enterprise Application Integration)
```
💡 기업 애플리케이션 통합

[재미있는 비유 🌉]
도시의 각 구역(SAP, 레거시, 홈택스 등)을 
연결하는 다리(Bridge) 역할

한샘에서의 역할: webMethods를 통해 SAP와 
40개 이상의 외부 시스템을 연결
```

### MSA (Microservices Architecture)
```
💡 마이크로서비스 아키텍처

[재미있는 비유 🍱]
- 모놀리식: 짜장면 한 그릇 (다 섞여있음)
- MSA: 반찬 여러 개 담긴 도시락 (각각 독립)

각 반찬(서비스)이 독립적으로 조리되고, 
하나가 상해도 다른 반찬은 멀쩡!
```

### RFC (Remote Function Call)
```
💡 원격 함수 호출 - SAP 시스템의 함수를 외부에서 호출

[재미있는 비유 📞]
다른 나라에 있는 친구에게 전화해서 
"너네 집 냉장고에 뭐 있어?" 물어보는 것

Java에서 SAP의 ABAP 함수를 호출하는 방식
```

### BAPI (Business Application Programming Interface)
```
💡 SAP가 제공하는 표준화된 비즈니스 API

[재미있는 비유 🔌]
만국 공통 어댑터 같은 것!
어느 나라 가전제품이든 꽂을 수 있음

표준화되어 있어서 재사용성이 높고 안정적
```

---

## 💾 데이터베이스 용어

### ORM (Object-Relational Mapping)
```
💡 객체와 관계형 DB를 매핑하는 기술

[재미있는 비유 🌐]
한국어(객체) ↔ 영어(테이블) 자동 번역기

Java 객체를 SQL로 직접 변환하지 않아도 
JPA/Hibernate가 알아서 번역해줌
```

### ETL (Extract, Transform, Load)
```
💡 데이터 추출 → 변환 → 적재 프로세스

[재미있는 비유 🚚]
이사할 때:
- Extract: 옛날 집에서 짐 빼기
- Transform: 새 집에 맞게 정리
- Load: 새 집에 넣기

Informatica PowerCenter로 2,500만 건 마이그레이션 경험
```

### 정합성 (Data Integrity)
```
💡 데이터가 정확하고 일관성 있는 상태

[재미있는 비유 🧩]
퍼즐 조각이 모두 맞물려 완성된 그림

"데이터 정합성 100% 달성" = 모든 퍼즐 조각이 완벽히 맞음
```

---

## 🔧 개발 용어

### TDD (Test-Driven Development)
```
💡 테스트 주도 개발 - 테스트 먼저, 구현은 나중에

[재미있는 비유 🎯]
- 기존: 활 쏘고 나서 과녁 그림
- TDD: 과녁 먼저 그리고 활 쏘기

테스트 커버리지 80~100% 달성의 비결!
```

### CI/CD (Continuous Integration/Continuous Deployment)
```
💡 지속적 통합 / 지속적 배포

[재미있는 비유 🏭]
- CI: 공장 컨베이어 벨트 (코드가 자동으로 합쳐짐)
- CD: 자동 배달 시스템 (합쳐진 제품이 바로 출하)

Jenkins를 활용한 자동화 배포 경험
```

### 프록시 패턴 (Proxy Pattern)
```
💡 대리인을 통해 객체에 접근하는 디자인 패턴

[재미있는 비유 🎭]
연예인 대신 매니저가 먼저 응대
"사인 받고 싶으시면 저에게 먼저 말씀하세요~"

Spring AOP, @Transactional이 이 패턴으로 동작
```

---

## 🌐 Spring 용어

### Bean
```
💡 Spring IoC 컨테이너가 관리하는 객체

[재미있는 비유 🌱]
Spring이라는 농부가 관리하는 콩(Bean)!
심고(생성), 물 주고(의존성 주입), 수확(사용), 정리(소멸)
모든 생명주기를 농부가 관리

@Component, @Service, @Repository, @Controller 등으로 등록
```

### ApplicationContext
```
💡 Spring IoC 컨테이너의 핵심 인터페이스

[재미있는 비유 🏢]
모든 Bean들이 모여 있는 "사무실 빌딩"
필요한 부서(Bean)를 안내데스크에서 찾아줌

getBean() 메서드로 필요한 객체를 요청
```

### @Autowired
```
💡 의존성 자동 주입 어노테이션

[재미있는 비유 🔌]
USB 포트처럼 꽂으면 자동으로 연결!
어떤 케이블(구현체)인지는 Spring이 알아서 찾아서 연결

생성자, 세터, 필드에 붙일 수 있음
```

---

## 📊 성능 용어

### Latency (지연 시간)
```
💡 요청부터 응답까지 걸리는 시간

[재미있는 비유 ⏱️]
식당에서 주문하고 음식 나올 때까지 시간
"저희 가게는 평균 5분이에요~"

세금계산서 처리 시간 5분 → 1.5분으로 단축!
```

### Throughput (처리량)
```
💡 단위 시간당 처리할 수 있는 작업량

[재미있는 비유 🏭]
공장에서 1시간에 몇 개 생산하는지
"우리 공장은 시간당 100개 생산!"

시스템이 감당할 수 있는 최대 부하를 나타냄
```

### 장애 발생률
```
💡 전체 운영 시간 중 장애가 발생한 비율

[재미있는 비유 💔]
1년 중 시스템이 아픈 날의 비율
"우리 시스템은 99.9% 건강해요!"

선제적 모니터링으로 장애 발생률 감소 경험
```

---

# 📌 마무리 체크리스트

## 면접 전 확인사항

- [ ] 이력서 내용 숙지 (특히 숫자와 성과)
- [ ] 한샘 최신 뉴스 확인
- [ ] 기술 용어 복습
- [ ] 질문할 내용 3개 이상 준비
- [ ] 예상 질문 답변 연습

## 면접 당일 준비물

- [ ] 이력서 출력본
- [ ] 필기도구
- [ ] 포트폴리오 (있다면)
- [ ] 긍정적인 마인드 💪

---

> 💡 **Remember**: 면접은 "나를 팔러 가는 것"이 아니라 
> "서로 맞는지 확인하는 대화"입니다.
> 
> 자신감을 가지고, 솔직하게, 그리고 열정을 보여주세요!

---

# 7. DB 심화: 인덱스, 쿼리 최적화, Redis, DBMS 비교

## 🚀 인덱스 심화

### Q1. 인덱스의 자료구조와 동작 원리를 설명해주세요.

### 💡 모범 답변

```
인덱스는 주로 B-Tree(Balanced Tree) 구조를 사용합니다.

[재미있는 비유 📖]
도서관에서 책을 찾는 상황을 생각해보세요.
- 인덱스 없음: 1층부터 5층까지 모든 책장을 뒤져야 함
- B-Tree 인덱스: "ㄱ-ㅁ은 2층, ㅂ-ㅎ은 3층" → 층 선택 → 서가 선택 → 책 찾기

[B-Tree 동작 원리]
1. 루트 노드에서 시작
2. 찾는 값과 비교하여 좌/우 자식 노드로 이동
3. 리프 노드에 도달하면 실제 데이터 위치(포인터) 획득
4. 해당 위치로 이동하여 데이터 조회

[시간 복잡도]
- Full Table Scan: O(n) - 데이터가 많아질수록 느려짐
- B-Tree Index: O(log n) - 데이터가 많아도 빠름!

예: 100만 건 데이터
- Full Scan: 100만 번 비교
- B-Tree: 약 20번 비교 (log₂ 1,000,000 ≈ 20)
```

### 🔑 인덱스 종류별 특징

| 종류 | 자료구조 | 특징 | 사용 시나리오 |
|------|----------|------|--------------|
| **B-Tree** | 균형 트리 | 범위 검색 우수, 가장 범용적 | WHERE, ORDER BY, GROUP BY |
| **Hash** | 해시 테이블 | 동등 비교(=)만 가능 | 정확한 값 매칭 |
| **Bitmap** | 비트 배열 | 카디널리티 낮은 컬럼에 적합 | 성별, 상태 값 |
| **Full-Text** | 역인덱스 | 텍스트 검색 최적화 | 검색 엔진, 문서 검색 |

---

### Q2. Clustered Index와 Non-Clustered Index의 차이점은?

### 💡 모범 답변

```
[Clustered Index]
- 테이블당 1개만 존재 가능
- 실제 데이터가 인덱스 순서대로 물리적으로 정렬됨
- 보통 Primary Key가 자동으로 Clustered Index가 됨

[재미있는 비유 📚]
- Clustered: 백과사전 - 내용이 가나다순으로 실제 배열됨
- Non-Clustered: 백과사전 뒤의 색인 - 키워드와 페이지 번호만 있음

[Non-Clustered Index]
- 테이블당 여러 개 생성 가능
- 인덱스 페이지에 키 값 + 데이터 위치 포인터 저장
- 실제 데이터는 별도 위치에 존재

[실제 경험 연결]
Credit Saison 프로젝트에서 2,500만 건 데이터 처리 시
- 회원 ID: Clustered Index (PK)
- 연체 상태, 가입일: Non-Clustered Index
이렇게 설계하여 데이터 정합성 100% 달성
```

### 🔑 비교 표

| 항목 | Clustered Index | Non-Clustered Index |
|------|-----------------|---------------------|
| 개수 | 테이블당 1개 | 여러 개 가능 |
| 데이터 정렬 | 물리적으로 정렬됨 | 정렬 안 됨 |
| 조회 속도 | 범위 검색 매우 빠름 | 단일 조회 빠름 |
| INSERT 성능 | 중간 삽입 시 느림 | 상대적으로 빠름 |
| 저장 공간 | 추가 공간 적음 | 인덱스 페이지 필요 |

---

### Q3. 인덱스가 있어도 풀 스캔이 발생하는 경우는?

### 💡 모범 답변

```
[풀 스캔 발생 케이스]

1️⃣ 인덱스 컬럼에 함수/연산 적용
❌ WHERE YEAR(created_date) = 2024
✅ WHERE created_date >= '2024-01-01' AND created_date < '2025-01-01'

2️⃣ LIKE 검색에서 와일드카드 선행
❌ WHERE name LIKE '%야령'  (앞에 % 있으면 인덱스 사용 불가)
✅ WHERE name LIKE '민%'    (뒤에 % 있으면 인덱스 사용 가능)

3️⃣ NULL 비교
❌ WHERE status = NULL     (문법적으로도 틀림)
✅ WHERE status IS NULL

4️⃣ OR 조건 (일부 DBMS)
❌ WHERE col1 = 'A' OR col2 = 'B'  (각각 인덱스가 있어도 풀 스캔 가능)
✅ UNION을 사용하거나 복합 인덱스 검토

5️⃣ 데이터 선택도가 높은 경우
- 전체 데이터의 20-30% 이상을 조회하면 
  옵티마이저가 풀 스캔이 더 효율적이라 판단

[재미있는 비유 🔍]
도서관에서 "ㄱ으로 시작하는 책"을 찾으려면 색인을 보면 됨.
하지만 "~으로 끝나는 책"을 찾으려면? 색인이 무용지물!
결국 전체를 뒤져야 함. 이게 LIKE '%값' 상황!
```

---

## 📊 쿼리 성능 최적화 실전

### Q4. EXPLAIN(실행계획)을 어떻게 분석하나요?

### 💡 모범 답변

```
[EXPLAIN 핵심 지표]

1️⃣ type (접근 방법) - 성능에 가장 중요!
   ALL < index < range < ref < eq_ref < const < system
   
   - ALL: Full Table Scan 😱 (최악)
   - index: Full Index Scan
   - range: 인덱스 범위 검색 (BETWEEN, <, >)
   - ref: 인덱스를 통한 비교 (JOIN, WHERE)
   - eq_ref: 유니크 인덱스로 1건만 조회
   - const: PK나 Unique로 1건 조회 (최고!)

2️⃣ rows (예상 검색 행 수)
   - 숫자가 작을수록 좋음
   - 실제 행 수와 크게 다르면 통계 갱신 필요

3️⃣ Extra (추가 정보)
   ❌ Using filesort: 별도 정렬 작업 (느림)
   ❌ Using temporary: 임시 테이블 사용 (느림)
   ✅ Using index: 커버링 인덱스 (빠름!)
   ✅ Using where: 인덱스 사용 후 추가 필터링

[실제 경험 - Usami Koyu 정유 프로젝트]
EXPLAIN 분석으로 문제 발견:
- type이 'ALL' → 풀 스캔 발생
- Using filesort → 비효율적 정렬

해결:
- 복합 인덱스 추가
- ORDER BY 컬럼을 인덱스에 포함
→ SQL 성능 분석 노하우 팀 내 공유
```

---

## 🔴 Redis 완벽 가이드

### Q5. Redis란 무엇이고, 왜 사용하나요?

### 💡 모범 답변

```
Redis(REmote DIctionary Server)는 
인메모리 키-값 저장소로, 초고속 데이터 처리를 위한 NoSQL DB입니다.

[재미있는 비유 🧠]
- RDBMS = 책장 (디스크) - 안전하지만 찾는 데 시간 걸림
- Redis = 메모장 (메모리) - 빠르게 적고 바로 확인 가능

[Redis를 사용하는 이유]
1️⃣ 속도: 1ms 미만 응답 (디스크 DB보다 10배 이상 빠름)
2️⃣ 캐싱: DB 부하 감소, 응답 시간 단축
3️⃣ 세션 관리: 다중 서버 환경에서 세션 공유
4️⃣ 실시간 처리: 좋아요, 조회수, 랭킹 등

[MySQL vs Redis 속도 비교]
- MySQL: 약 1-10ms
- Redis: 약 0.1ms
→ 10~100배 빠름!
```

### 🔑 Redis 주요 사용 사례

| 사용 사례 | 설명 | 예시 |
|----------|------|------|
| **캐싱** | 자주 조회하는 데이터 저장 | 상품 정보, 게시글 목록 |
| **세션 관리** | 로그인 상태 유지 | JWT 토큰, 로그인 세션 |
| **실시간 순위** | Sorted Set으로 랭킹 | 게임 리더보드, 인기 검색어 |
| **메시지 큐** | Pub/Sub 패턴 | 실시간 알림, 채팅 |
| **Rate Limiting** | API 호출 제한 | 초당 100건 제한 |

---

### Q6. Redis 캐싱 전략을 설명해주세요.

### 💡 모범 답변

```
[1. Look-Aside (Lazy Loading) 패턴] ⭐ 가장 많이 사용

┌──────────┐     1. 캐시 확인     ┌──────────┐
│  Client  │ ───────────────────▶│  Redis   │
└──────────┘                     └──────────┘
     │                                │
     │  3. DB 조회 (캐시 미스 시)       │ 2. Hit/Miss
     ▼                                │
┌──────────┐                          │
│   DB     │◀─────────────────────────┘
└──────────┘     4. 캐시에 저장

[장점] Redis 장애 시에도 서비스 가능
[단점] 첫 요청은 느림 (Cache Miss)

[2. Write-Through 패턴]
데이터 저장 시 DB와 캐시에 동시 저장

[장점] 캐시 항상 최신 상태
[단점] 쓰기가 느림, 사용 안 하는 데이터도 캐싱

[3. Write-Behind (Write-Back) 패턴]
캐시에만 먼저 저장, 나중에 DB에 일괄 저장

[장점] 쓰기 성능 최고
[단점] 데이터 유실 위험

[실제 적용 권장]
세금계산서 시스템 같은 경우:
- 조회가 많은 데이터: Look-Aside
- 실시간 발행 현황: Write-Through + TTL 설정
```

---

### Q7. Redis의 데이터 타입과 활용 예시를 알려주세요.

### 💡 모범 답변

```
[Redis 데이터 타입]

1️⃣ String (문자열)
   SET user:1:name "민야령"
   GET user:1:name
   → 단순 값 저장, 세션, 캐시

2️⃣ Hash (해시)
   HSET user:1 name "민야령" email "test@example.com"
   HGET user:1 name
   → 객체 저장 (사용자 정보)

3️⃣ List (리스트)
   LPUSH queue:jobs "job1" "job2"
   RPOP queue:jobs
   → 메시지 큐, 최근 본 상품

4️⃣ Set (집합)
   SADD tags:post:1 "spring" "java" "backend"
   SMEMBERS tags:post:1
   → 태그, 좋아요 사용자 (중복 불가!)

5️⃣ Sorted Set (정렬된 집합) ⭐
   ZADD leaderboard 100 "user1" 200 "user2"
   ZRANGE leaderboard 0 -1 WITHSCORES
   → 실시간 랭킹, 우선순위 큐

[재미있는 비유 🎮]
- String: 메모장 한 줄
- Hash: 명함 (이름, 전화번호, 이메일)
- List: 줄 서기 (선입선출)
- Set: 출석부 (중복 없음)
- Sorted Set: 성적표 (점수순 정렬)
```

---

### Q8. Redis와 RDBMS를 함께 사용할 때 주의점은?

### 💡 모범 답변

```
[핵심 이슈: 데이터 정합성]

캐시(Redis)와 DB 데이터가 불일치할 수 있음!

[해결 전략]

1️⃣ TTL(Time To Live) 설정
   SET key value EX 3600  // 1시간 후 자동 삭제
   → 오래된 캐시가 자동으로 만료됨

2️⃣ Cache Invalidation (캐시 무효화)
   - 데이터 변경 시 관련 캐시 삭제
   - DELETE cache:user:1
   
3️⃣ Cache Warming (캐시 예열)
   - 서비스 시작 전 자주 쓰는 데이터를 미리 캐싱
   - 예: 티켓 판매 전 상품 정보 미리 로딩

[주의사항 체크리스트]
✅ 캐시 키 네이밍 규칙 통일 (예: service:entity:id)
✅ 만료 시간 비즈니스에 맞게 설정
✅ Redis 장애 시 DB로 Fallback 로직 구현
✅ 메모리 사용량 모니터링 (maxmemory 설정)

[재미있는 비유 📋]
Redis는 "칠판 메모", DB는 "서류철"
- 칠판에 적어둔 게 오래되면 실제 서류와 달라질 수 있음
- 주기적으로 칠판을 지우고(TTL) 새로 적거나
- 서류가 바뀌면 칠판도 같이 수정(Invalidation)
```

---

## 🗄️ DBMS 비교

### Q9. MySQL, PostgreSQL, Oracle, MariaDB의 차이점은?

### 💡 모범 답변

```
[한눈에 보는 비교]

┌─────────────┬─────────────┬─────────────┬─────────────┐
│   MySQL     │ PostgreSQL  │   Oracle    │   MariaDB   │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 가장 대중적 │ 기능이 풍부 │ 엔터프라이즈│ MySQL 호환  │
│ 읽기 최적화 │ 표준 SQL    │ 최고 성능   │ 오픈소스    │
│ 간단한 설정 │ 확장성 우수 │ 고가 라이선스│ 더 빠른 개발│
└─────────────┴─────────────┴─────────────┴─────────────┘

[상세 비교]

1️⃣ MySQL
- 장점: 가볍고 빠름, 설정 쉬움, 커뮤니티 큼
- 단점: 복잡한 쿼리 성능 ↓, 일부 표준 SQL 미지원
- 사용: 웹 서비스, 스타트업, 읽기 많은 서비스

2️⃣ PostgreSQL
- 장점: 표준 SQL 준수, 복잡한 쿼리 우수, 확장성
- 단점: 초기 설정 복잡, 단순 읽기는 MySQL보다 느림
- 사용: 분석 시스템, GIS, 복잡한 비즈니스 로직

3️⃣ Oracle
- 장점: 최고 성능, 안정성, 기술 지원
- 단점: 매우 비쌈 (라이선스), 복잡한 관리
- 사용: 대기업, 금융권, 미션 크리티컬 시스템

4️⃣ MariaDB
- 장점: MySQL 완전 호환, 더 빠른 업데이트, 무료
- 단점: Oracle 인수 후 MySQL과 차이 발생
- 사용: MySQL 대체, 새 프로젝트

[실제 경험 연결]
- 세금계산서 시스템: MariaDB 선택
  → MySQL 호환 + 오픈소스 + Spring Data JPA 지원
- 일본 프로젝트: Oracle 사용
  → 금융/증권 시스템 안정성 요구
```

### 🔑 DBMS 선택 기준

| 상황 | 추천 DBMS | 이유 |
|------|----------|------|
| 스타트업, 빠른 개발 | MySQL/MariaDB | 쉽고 빠름 |
| 복잡한 분석 쿼리 | PostgreSQL | 윈도우 함수, CTE 강력 |
| 금융/미션 크리티컬 | Oracle | 안정성, 기술 지원 |
| MySQL에서 이전 | MariaDB | 완벽 호환 |
| 클라우드 환경 | 각 클라우드 매니지드 서비스 | 관리 편의성 |

---

### Q10. NoSQL과 RDBMS는 언제 각각 사용하나요?

### 💡 모범 답변

```
[RDBMS 선택 시나리오]
✅ 데이터 정합성이 매우 중요 (금융, 회계)
✅ 복잡한 JOIN이 많은 경우
✅ 트랜잭션 ACID 보장 필요
✅ 스키마가 명확하고 변경이 적음

예: 세금계산서 시스템, ERP, 은행 계좌

[NoSQL 선택 시나리오]
✅ 대량의 읽기/쓰기 처리
✅ 스키마가 자주 변경됨
✅ 수평적 확장(Scale-out) 필요
✅ 비정형 데이터 (로그, 문서)

예: 로그 저장, 세션 관리, 실시간 분석

[재미있는 비유 🏢]
- RDBMS: 도서관 서가 (분류 체계 엄격, 찾기 쉬움)
- NoSQL: 창고 (자유롭게 쌓기, 빠르게 넣고 빼기)

[현실에서는...]
보통 둘 다 사용합니다!
- RDBMS: 핵심 비즈니스 데이터
- Redis/MongoDB: 캐시, 세션, 로그 등 보조 역할
```

---

# 8. 백엔드 실무 필수 지식 (책 기반)

> 📚 참고 도서
> - 《주니어 백엔드 개발자가 반드시 알아야 할 실무 지식》 (최범균, 한빛미디어)
> - 《SQL 레벨업》 (미크, 한빛미디어)

---

## 📖 《주니어 백엔드 개발자가 반드시 알아야 할 실무 지식》 핵심 정리

### 책 전체 구조

```
1장: 들어가며 - 코딩을 할 수 있게 된 것일 뿐
2장: 느린 서비스, 어디부터 봐야 할까 (처리량, 응답시간, 병목)
3장: 성능을 좌우하는 DB 설계와 쿼리
4장: 외부 연동이 문제일 때 (타임아웃, 재시도, 서킷브레이커)
5장: 비동기 연동, 언제 어떻게 써야 할까
6장: 동시성, 데이터가 꼬이기 전에 잡아야 한다
7장: IO 병목, 어떻게 해결하지
8장: 실무에서 꼭 필요한 보안 지식
9장: 최소한 알고 있어야 할 서버 지식
10장: 모르면 답답해지는 네트워크 기초
11장: 자주 쓰는 서버 구조와 설계 패턴
```

---

### 핵심 1: 처리량과 응답 시간 (2장)

```
[처리량 (Throughput)]
단위 시간당 처리할 수 있는 요청 수
예: 초당 1000 TPS (Transactions Per Second)

[응답 시간 (Response Time)]
요청 ~ 응답까지 걸리는 시간
예: 평균 200ms, P99 500ms

[재미있는 비유 🍜]
라면 가게로 비유하면:
- 처리량: 1시간에 몇 그릇 팔 수 있는지
- 응답 시간: 주문 후 라면 나오는 시간

둘 다 중요하지만, 상황에 따라 우선순위가 다름!

[병목 지점 찾기]
1. APM(Application Performance Monitoring) 도구 활용
2. 슬로우 쿼리 로그 분석
3. 네트워크 지연 측정
4. CPU/메모리 사용량 모니터링

[실제 경험 연결]
세금계산서 시스템에서 처리 시간 70% 단축:
- 병목: SAP RFC 호출 대기 시간
- 해결: 비동기 처리 + 캐싱 도입
```

---

### 핵심 2: 외부 연동 문제 해결 (4장) ⭐ 매우 중요

```
[타임아웃 설정]
Connection Timeout: 연결 수립까지 대기 시간 (보통 3-5초)
Read Timeout: 응답 대기 시간 (비즈니스에 맞게)

[재미있는 비유 ☎️]
전화로 비유하면:
- Connection Timeout: 전화 연결음 기다리는 시간
- Read Timeout: 상대방이 말할 때까지 기다리는 시간

[재시도 전략]
1. 단순 재시도: 같은 간격으로 N번 시도
2. 지수 백오프: 1초 → 2초 → 4초 → 8초... (권장)
3. 지터 추가: 랜덤 시간 더해서 동시 요청 방지

[서킷 브레이커 패턴]
외부 서비스 장애 시 빠르게 실패하여 전체 시스템 보호

┌─────────┐     ┌──────────┐     ┌─────────┐
│ CLOSED  │────▶│   OPEN   │────▶│HALF-OPEN│
│ (정상)   │     │ (차단)   │     │ (테스트) │
└─────────┘     └──────────┘     └─────────┘
     ▲                              │
     └──────────────────────────────┘
                 성공 시 복구

[실제 경험 - 규슈 전력 프로젝트]
금융기관 연동 비정상 종료 → 서킷 브레이커 검토
→ 외부 금융기관 연동 오류 90% 감소
```

---

### 핵심 3: 동시성 제어 (6장)

```
[동시성 문제 예시]
잔액 1000원인 계좌에서 두 사람이 동시에 800원 출금 시도
→ 둘 다 성공하면 -600원 😱

[해결 방법]

1️⃣ DB 수준 락 (비관적 락)
   SELECT * FROM account WHERE id = 1 FOR UPDATE
   → 다른 트랜잭션이 접근 못함

2️⃣ 낙관적 락 (버전 관리)
   UPDATE account SET balance = 200, version = 2 
   WHERE id = 1 AND version = 1
   → 버전 다르면 업데이트 실패

3️⃣ 분산 락 (Redis)
   SETNX lock:account:1 "locked"
   → 여러 서버 환경에서 락 공유

[어떤 락을 사용할까?]
- 충돌 적음 → 낙관적 락 (성능 좋음)
- 충돌 많음 → 비관적 락 (안정적)
- 분산 환경 → Redis 분산 락

[실제 적용 - 세금계산서 시스템]
이중 발행 방지를 위해 낙관적 락 + 유니크 제약조건
→ 이중 발행 오류 0건 달성!
```

---

### 핵심 4: 비동기 연동 (5장)

```
[동기 vs 비동기]

동기: A 작업 → 완료 기다림 → B 작업
비동기: A 작업 → (기다리지 않고) B 작업 → A 완료 시 콜백

[재미있는 비유 ☕]
카페에서:
- 동기: 주문 → 음료 나올 때까지 카운터 앞에서 대기
- 비동기: 주문 → 진동벨 받고 자리에서 대기 → 벨 울리면 픽업

[비동기 처리 방법]

1️⃣ @Async (Spring)
   @Async
   public CompletableFuture<Void> sendEmail() {...}
   
2️⃣ 메시지 큐 (Kafka, RabbitMQ)
   - 생산자가 메시지 발행
   - 소비자가 메시지 처리
   - 결합도 낮음, 확장성 좋음

3️⃣ 이벤트 기반 아키텍처
   - 도메인 이벤트 발행/구독
   - 마이크로서비스에서 많이 사용

[주의사항]
- 순서 보장 필요 시 별도 처리
- 에러 핸들링 복잡해짐
- 디버깅 어려움 → 로그 중요!

[실제 적용]
세금계산서 발행 완료 알림:
- 발행 완료 → 이벤트 발행 → 알림 서비스가 비동기 처리
- 메인 트랜잭션에 영향 없이 알림 전송
```

---

### 핵심 5: 보안 기본 (8장)

```
[인증(Authentication) vs 인가(Authorization)]
- 인증: "당신이 누구인가?" (로그인)
- 인가: "당신이 무엇을 할 수 있는가?" (권한)

[필수 보안 체크리스트]

1️⃣ SQL Injection 방지
   ❌ "SELECT * FROM user WHERE id = '" + userId + "'"
   ✅ PreparedStatement 또는 ORM 사용

2️⃣ XSS (Cross-Site Scripting) 방지
   - 입력값 이스케이프 처리
   - Content Security Policy 헤더 설정

3️⃣ CSRF (Cross-Site Request Forgery) 방지
   - CSRF 토큰 사용
   - SameSite 쿠키 설정

4️⃣ 비밀번호 저장
   ❌ 평문 저장
   ❌ MD5, SHA1 (취약)
   ✅ BCrypt, Argon2 (솔트 + 느린 해시)

5️⃣ 민감 정보 암호화
   - 주민번호, 카드번호 등 암호화 필수
   - AES-256 등 표준 알고리즘 사용

[실제 경험 - MONEX 증권사 MFA 시스템]
- SMS 인증 추가로 부정 로그인 30% 감소
- 비밀번호 기반 부정 접속 0건 달성
```

---

## 📖 《SQL 레벨업》 핵심 정리

### 책 핵심 철학

```
"SQL은 집합을 다루는 언어다"

반복문(절차적) → 집합 연산(선언적)으로 사고 전환 필요!
```

---

### SQL 핵심 1: 결합(JOIN) 성능

```
[JOIN 알고리즘]

1️⃣ Nested Loop Join
   - 이중 for문처럼 동작
   - 소량 데이터에 적합
   - 드라이빙 테이블 선택이 중요!

2️⃣ Hash Join
   - 해시 테이블 생성 후 매칭
   - 대량 데이터에 효율적
   - 메모리 사용량 큼

3️⃣ Sort Merge Join
   - 정렬 후 머지
   - 정렬된 데이터에 효율적

[성능 팁]
- 작은 테이블이 드라이빙 테이블이 되도록
- JOIN 컬럼에 인덱스 생성
- 불필요한 컬럼 조회 피하기
```

---

### SQL 핵심 2: 서브쿼리 vs JOIN

```
[상관 서브쿼리 문제]
SELECT *
FROM orders o
WHERE o.price > (
    SELECT AVG(price) 
    FROM orders 
    WHERE customer_id = o.customer_id  -- 외부 참조!
);
→ 행마다 서브쿼리 실행 = 매우 느림!

[해결: JOIN으로 변환]
SELECT o.*
FROM orders o
JOIN (
    SELECT customer_id, AVG(price) as avg_price
    FROM orders
    GROUP BY customer_id
) sub ON o.customer_id = sub.customer_id
WHERE o.price > sub.avg_price;
→ 한 번만 계산!

[재미있는 비유 📞]
- 상관 서브쿼리: 매번 전화해서 물어봄
- JOIN: 한 번에 자료 받아서 비교
```

---

### SQL 핵심 3: 윈도우 함수 활용

```
[윈도우 함수란?]
행 그룹에 대해 계산하되, 행을 합치지 않음

[주요 윈도우 함수]
ROW_NUMBER(): 순번 매기기
RANK(): 순위 (동점 시 같은 순위, 다음 순위 건너뜀)
DENSE_RANK(): 순위 (동점 시 같은 순위, 다음 순위 이어감)
LAG(): 이전 행 값
LEAD(): 다음 행 값
SUM() OVER(): 누적 합계

[예제: 부서별 급여 순위]
SELECT 
    name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;

[실제 활용]
- 고객별 최근 주문 조회
- 월별 매출 증감률 계산
- 연속 로그인 일수 계산
```

---

### SQL 핵심 4: 실행 계획 읽기

```
[실행 계획에서 봐야 할 것]

1️⃣ Seq Scan (Full Table Scan)
   → 인덱스 없이 전체 스캔
   → 큰 테이블에서 위험!

2️⃣ Index Scan / Index Only Scan
   → 인덱스 사용 중 (좋음!)
   → Index Only가 더 좋음 (테이블 접근 X)

3️⃣ Sort
   → ORDER BY 처리
   → Using filesort면 추가 정렬 작업

4️⃣ Hash Join / Nested Loop
   → JOIN 방식
   → 데이터 크기에 따라 적합한 방식 다름

[최적화 순서]
1. WHERE 절에 인덱스 사용 가능한지 확인
2. JOIN 컬럼에 인덱스 있는지 확인
3. SELECT에 필요한 컬럼만 명시
4. 서브쿼리 → JOIN 변환 검토
```

---

## 📝 면접 최종 체크리스트 (추가)

### DB 관련 필수 암기

- [ ] B-Tree 인덱스 동작 원리
- [ ] Clustered vs Non-Clustered 차이
- [ ] 인덱스 안 타는 케이스 5가지
- [ ] Redis 사용 이유 3가지
- [ ] 캐싱 전략 (Look-Aside, Write-Through)
- [ ] MySQL vs PostgreSQL 선택 기준

### 백엔드 실무 필수 암기

- [ ] 타임아웃 설정 이유
- [ ] 서킷 브레이커 패턴
- [ ] 낙관적 락 vs 비관적 락
- [ ] SQL Injection 방지 방법
- [ ] 동기 vs 비동기 처리 차이

---

# 9. Java 핵심 개념

## ☕ Java 기본 개념

### Q1. JVM, JRE, JDK의 차이점을 설명해주세요.

### 💡 모범 답변

```
[JDK ⊃ JRE ⊃ JVM 관계]

┌─────────────────────────────────────────────┐
│  JDK (Java Development Kit)                 │
│  - 개발 도구 (javac, jar, javadoc 등)        │
│  ┌─────────────────────────────────────┐   │
│  │  JRE (Java Runtime Environment)     │   │
│  │  - 실행 환경 (라이브러리, 클래스 등)   │   │
│  │  ┌─────────────────────────────┐   │   │
│  │  │  JVM (Java Virtual Machine) │   │   │
│  │  │  - 바이트코드 실행 엔진       │   │   │
│  │  └─────────────────────────────┘   │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘

[재미있는 비유 🎮]
- JVM: 게임기 본체 (실행 담당)
- JRE: 게임기 + 기본 게임 (실행 환경)
- JDK: 게임기 + 기본 게임 + 게임 제작 도구 (개발까지 가능)

[Java 실행 과정]
1. .java (소스코드) 
   ↓ javac (컴파일러)
2. .class (바이트코드)
   ↓ JVM (실행)
3. 기계어로 변환 → 실행

[Write Once, Run Anywhere]
JVM만 있으면 어떤 OS에서도 실행 가능!
- Windows JVM, Linux JVM, Mac JVM 각각 존재
- 같은 .class 파일이 모든 환경에서 동작
```

---

### Q2. Java의 메모리 구조(JVM 메모리)를 설명해주세요.

### 💡 모범 답변

```
[JVM 메모리 구조]

┌─────────────────────────────────────────────┐
│                Method Area                  │
│  - 클래스 정보, static 변수, 상수 풀         │
│  - 모든 스레드 공유                          │
├─────────────────────────────────────────────┤
│                   Heap                      │
│  - 객체, 배열 저장                           │
│  - GC 대상                                  │
│  - 모든 스레드 공유                          │
├──────────────────────┬──────────────────────┤
│    Stack (스레드1)    │   Stack (스레드2)    │
│  - 지역변수, 매개변수  │  - 지역변수, 매개변수 │
│  - 메서드 호출 정보    │  - 메서드 호출 정보   │
├──────────────────────┼──────────────────────┤
│ PC Register (스레드1) │ PC Register (스레드2)│
├──────────────────────┼──────────────────────┤
│ Native Stack (스레드1)│ Native Stack (스레드2)│
└──────────────────────┴──────────────────────┘

[재미있는 비유 🏢]
- Method Area: 회사 규칙서 (모든 직원 공유)
- Heap: 공용 창고 (물건 보관, 청소 필요)
- Stack: 각자 책상 (개인 업무 공간)

[중요 포인트]
1. Heap은 GC가 관리 → 메모리 누수 주의!
2. Stack은 메서드 종료 시 자동 정리
3. static 변수는 Method Area에 저장 → 프로그램 종료까지 유지
```

---

### Q3. Garbage Collection(GC)의 동작 원리를 설명해주세요.

### 💡 모범 답변

```
[GC란?]
더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제하는 기능

[재미있는 비유 🧹]
청소부가 집안을 돌아다니며:
- "이 물건 주인 있어요?" → 주인 없으면 버림!
- 주기적으로 청소 (GC 실행)

[Heap 메모리 구조 (Generational GC)]

┌─────────────────────────────────────────┐
│              Young Generation            │
│  ┌─────────┬─────────┬─────────┐       │
│  │  Eden   │Survivor0│Survivor1│       │
│  │ (생성)  │ (생존1) │ (생존2) │       │
│  └─────────┴─────────┴─────────┘       │
│              ↓ Minor GC                  │
├─────────────────────────────────────────┤
│              Old Generation              │
│  (오래 살아남은 객체)                     │
│              ↓ Major GC (Full GC)       │
└─────────────────────────────────────────┘

[GC 과정]
1. 객체 생성 → Eden 영역에 할당
2. Eden이 가득 차면 → Minor GC 실행
3. 살아남은 객체 → Survivor 영역으로 이동
4. 여러 번 살아남으면 → Old Generation으로 이동
5. Old Generation이 가득 차면 → Major GC (Full GC)

[GC 튜닝 포인트]
- Full GC는 Stop-The-World 발생 → 성능 저하!
- 객체를 짧게 쓰고 빨리 버리는 게 좋음
- 불필요한 객체 참조 제거 (list = null)
```

### 🔑 GC 알고리즘 종류

| GC 종류 | 특징 | 사용 시나리오 |
|---------|------|--------------|
| **Serial GC** | 싱글 스레드, 단순 | 작은 애플리케이션 |
| **Parallel GC** | 멀티 스레드 | 처리량 중요 |
| **CMS GC** | 응답 시간 중요 | 레거시 웹 서버 |
| **G1 GC** ⭐ | 균형 잡힌 성능 | Java 9+ 기본 |
| **ZGC** | 초저지연 (10ms 이하) | 대용량 힙, 실시간 |

---

### Q4. Java의 접근 제어자를 설명해주세요.

### 💡 모범 답변

```
[접근 제어자 범위]

┌────────────┬─────────┬─────────┬──────────┬─────────┐
│            │ 클래스  │ 패키지  │ 상속클래스│ 전체    │
│            │  내부   │  내부   │  (다른패키지) │         │
├────────────┼─────────┼─────────┼──────────┼─────────┤
│ private    │   ✅   │   ❌   │    ❌    │   ❌   │
│ (default)  │   ✅   │   ✅   │    ❌    │   ❌   │
│ protected  │   ✅   │   ✅   │    ✅    │   ❌   │
│ public     │   ✅   │   ✅   │    ✅    │   ✅   │
└────────────┴─────────┴─────────┴──────────┴─────────┘

[재미있는 비유 🏠]
- private: 내 방 (나만 들어감)
- default: 우리 집 (가족만)
- protected: 친척집까지 (상속 관계)
- public: 공원 (누구나 접근)

[캡슐화 원칙]
- 필드는 private으로!
- 메서드로 접근 (getter/setter)

public class User {
    private String name;      // 외부 직접 접근 금지
    
    public String getName() { // 메서드로 접근
        return name;
    }
    
    public void setName(String name) {
        // 유효성 검사 가능!
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }
}
```

---

### Q5. final, finally, finalize의 차이점은?

### 💡 모범 답변

```
[한눈에 비교]

┌──────────┬─────────────────────────────────────┐
│  final   │ 변경 불가! (상수, 상속금지, 오버라이드금지) │
├──────────┼─────────────────────────────────────┤
│ finally  │ try-catch에서 항상 실행되는 블록       │
├──────────┼─────────────────────────────────────┤
│ finalize │ GC 전에 호출 (deprecated, 사용 금지!)  │
└──────────┴─────────────────────────────────────┘

[1️⃣ final 사용법]
// 상수 (값 변경 불가)
final int MAX_SIZE = 100;

// 상속 금지 클래스
final class StringUtils { }

// 오버라이드 금지 메서드
public final void criticalMethod() { }

// 참조 변경 불가 (내용은 변경 가능!)
final List<String> list = new ArrayList<>();
list.add("OK");  // ✅ 내용 추가 가능
list = new ArrayList<>();  // ❌ 참조 변경 불가

[2️⃣ finally 사용법]
try {
    // 예외 발생 가능 코드
    connection = getConnection();
} catch (Exception e) {
    // 예외 처리
} finally {
    // 항상 실행! (리소스 정리)
    if (connection != null) {
        connection.close();
    }
}

[3️⃣ finalize - 사용하지 마세요! ⚠️]
- Java 9부터 deprecated
- GC 시점 불확실
- 대안: try-with-resources, Cleaner API
```

---

### Q6. 추상 클래스(Abstract Class)와 인터페이스(Interface)의 차이점은?

### 💡 모범 답변

```
[비교 표]

┌────────────────┬──────────────────┬──────────────────┐
│      항목       │   추상 클래스     │    인터페이스     │
├────────────────┼──────────────────┼──────────────────┤
│ 키워드         │ abstract class   │ interface        │
│ 다중 상속      │ ❌ 불가능         │ ✅ 가능          │
│ 구현 메서드    │ ✅ 가질 수 있음   │ ✅ default 메서드│
│ 멤버 변수      │ 모든 종류 가능    │ public static final│
│ 생성자         │ ✅ 있음          │ ❌ 없음          │
│ 목적           │ IS-A (상속)      │ CAN-DO (기능)    │
└────────────────┴──────────────────┴──────────────────┘

[재미있는 비유 🎭]
- 추상 클래스: "너는 동물이야" (IS-A)
  → Dog extends Animal (개는 동물이다)
  
- 인터페이스: "너는 수영할 수 있어" (CAN-DO)
  → Dog implements Swimmable (개는 수영할 수 있다)

[언제 무엇을 사용?]

// 추상 클래스: 공통 기능 + 일부 구현 공유
abstract class Animal {
    protected String name;  // 상태 공유
    
    public void eat() {     // 구현된 메서드
        System.out.println("먹는다");
    }
    
    abstract void sound();  // 하위 클래스에서 구현
}

// 인터페이스: 기능 명세 (다중 구현 가능)
interface Flyable {
    void fly();  // 구현 강제
    
    default void land() {  // Java 8+ 기본 구현
        System.out.println("착륙");
    }
}

// 조합 사용
class Bird extends Animal implements Flyable {
    @Override
    void sound() { System.out.println("짹짹"); }
    
    @Override
    public void fly() { System.out.println("날다"); }
}
```

---

### Q7. Checked Exception과 Unchecked Exception의 차이점은?

### 💡 모범 답변

```
[예외 계층 구조]

                    Throwable
                   /         \
               Error      Exception
            (처리 불가)   /         \
                    Checked    RuntimeException
                   Exception    (Unchecked)
                   
[비교]

┌────────────────┬──────────────────┬──────────────────┐
│      항목       │ Checked Exception│Unchecked Exception│
├────────────────┼──────────────────┼──────────────────┤
│ 컴파일 체크    │ ✅ 반드시 처리    │ ❌ 선택적       │
│ 처리 방법      │ try-catch/throws │ 선택적          │
│ 발생 시점      │ 컴파일 타임      │ 런타임          │
│ 예시           │ IOException      │ NullPointerException│
│                │ SQLException     │ ArrayIndexOutOfBounds│
└────────────────┴──────────────────┴──────────────────┘

[재미있는 비유 📋]
- Checked: 비행기 탑승 전 체크리스트 (필수 확인!)
- Unchecked: 운전 중 돌발 상황 (예측 불가)

[실제 코드 예시]

// Checked Exception - 반드시 처리 필요
public void readFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(
        new FileReader(path)  // IOException 발생 가능
    );
}

// Unchecked Exception - 선택적 처리
public void divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("0으로 나눌 수 없음");
    }
    return a / b;  // ArithmeticException 가능
}

[Best Practice]
- 복구 가능한 상황 → Checked Exception
- 프로그래밍 오류 → Unchecked Exception
- 요즘 트렌드: Unchecked Exception 선호 (Spring도!)
```

---

### Q8. == 연산자와 equals() 메서드의 차이점은?

### 💡 모범 답변

```
[핵심 차이]

== : 참조(주소) 비교 (같은 객체인가?)
equals() : 값(내용) 비교 (같은 내용인가?)

[재미있는 비유 🏠]
두 명함을 비교할 때:
- == : "같은 명함 카드인가?" (물리적 동일)
- equals() : "명함에 적힌 정보가 같은가?" (내용 동일)

[코드 예시]

// 1. 문자열 비교
String s1 = new String("hello");
String s2 = new String("hello");
String s3 = "hello";
String s4 = "hello";

s1 == s2      // false (다른 객체)
s1.equals(s2) // true  (같은 내용)
s3 == s4      // true  (String Pool - 같은 객체!)
s3.equals(s4) // true  (같은 내용)

// 2. 객체 비교 - equals 오버라이드 필수!
class User {
    private Long id;
    private String name;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

[중요] equals를 오버라이드하면 hashCode도 반드시 오버라이드!
→ HashMap, HashSet 정상 동작을 위해 필수!
```

---

### Q9. String, StringBuilder, StringBuffer의 차이점은?

### 💡 모범 답변

```
[비교 표]

┌──────────────┬───────────┬───────────┬───────────┐
│     항목      │  String   │StringBuilder│StringBuffer│
├──────────────┼───────────┼───────────┼───────────┤
│ 불변성       │ 불변(Immutable)│ 가변(Mutable)│ 가변(Mutable)│
│ 스레드 안전  │ ✅ 안전   │ ❌ 불안전  │ ✅ 안전   │
│ 성능         │ 느림      │ 빠름 ⭐   │ 중간      │
│ 사용 시나리오│ 변경 없음 │ 단일 스레드│ 멀티 스레드│
└──────────────┴───────────┴───────────┴───────────┘

[재미있는 비유 📝]
- String: 볼펜 (수정 불가, 새로 쓰기)
- StringBuilder: 연필 (자유롭게 수정)
- StringBuffer: 지우개 딸린 연필 + 자물쇠 (수정 + 안전)

[성능 비교]

// ❌ String 연결 - 매번 새 객체 생성 (느림!)
String result = "";
for (int i = 0; i < 10000; i++) {
    result += i;  // 매번 새 String 객체 생성!
}

// ✅ StringBuilder - 같은 객체에서 수정 (빠름!)
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);  // 같은 객체 수정
}
String result = sb.toString();

[사용 가이드]
- 문자열 변경 없음 → String
- 단일 스레드에서 문자열 조작 → StringBuilder ⭐ (가장 많이 사용)
- 멀티 스레드에서 문자열 조작 → StringBuffer

[실제 경험]
대용량 로그 문자열 생성 시 StringBuilder 사용으로
메모리 사용량 감소 및 성능 향상
```

---

### Q10. Java 8의 주요 기능을 설명해주세요.

### 💡 모범 답변

```
[Java 8 핵심 기능]

1️⃣ Lambda Expression (람다 표현식)
// Before
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("클릭!");
    }
});

// After (Lambda)
button.addActionListener(e -> System.out.println("클릭!"));

2️⃣ Stream API
List<String> names = Arrays.asList("Kim", "Lee", "Park");

// 필터링 + 변환 + 수집
List<String> result = names.stream()
    .filter(name -> name.startsWith("K"))  // 필터
    .map(String::toUpperCase)              // 변환
    .collect(Collectors.toList());         // 수집

3️⃣ Optional
// NullPointerException 방지
Optional<User> userOpt = userRepository.findById(1L);

String name = userOpt
    .map(User::getName)
    .orElse("Unknown");  // null이면 기본값

4️⃣ 인터페이스 default 메서드
interface Vehicle {
    void start();
    
    default void stop() {  // 기본 구현 제공
        System.out.println("정지");
    }
}

5️⃣ 새로운 Date/Time API
LocalDate today = LocalDate.now();
LocalDateTime now = LocalDateTime.now();
LocalDate birthday = LocalDate.of(1990, 1, 1);

[실제 프로젝트 적용]
세금계산서 시스템에서:
- Stream API로 데이터 필터링/변환 간결하게
- Optional로 null 안전하게 처리
- Lambda로 콜백 로직 간소화
```

---

### Q11. 제네릭(Generic)이란 무엇인가요?

### 💡 모범 답변

```
[제네릭이란?]
컴파일 시점에 타입을 체크하여 타입 안전성을 보장하는 기능

[재미있는 비유 📦]
- 제네릭 없는 박스: 아무거나 담을 수 있음 (위험!)
- 제네릭 있는 박스: "사과 전용 박스" 라벨 붙임 (안전!)

[사용 예시]

// 제네릭 없이 (Java 1.4 이전)
List list = new ArrayList();
list.add("문자열");
list.add(123);  // 뭐든 넣을 수 있음!
String s = (String) list.get(1);  // 런타임 에러! 😱

// 제네릭 사용 (권장)
List<String> list = new ArrayList<>();
list.add("문자열");
list.add(123);  // 컴파일 에러! ✅ 미리 발견
String s = list.get(0);  // 캐스팅 불필요

[제네릭 클래스 만들기]
public class Box<T> {
    private T item;
    
    public void set(T item) { this.item = item; }
    public T get() { return item; }
}

Box<String> stringBox = new Box<>();
Box<Integer> intBox = new Box<>();

[와일드카드]
<?> : 모든 타입
<? extends Number> : Number의 하위 타입 (상한)
<? super Integer> : Integer의 상위 타입 (하한)

// 예시
public void printNumbers(List<? extends Number> list) {
    for (Number n : list) {
        System.out.println(n);
    }
}
```

---

### Q12. 동기화(Synchronization)와 멀티스레딩을 설명해주세요.

### 💡 모범 답변

```
[멀티스레딩 문제]
여러 스레드가 동시에 같은 자원에 접근하면 데이터 불일치 발생!

[재미있는 비유 🚻]
화장실이 1개인데 여러 사람이 동시에 들어가면?
→ synchronized = 자물쇠! 한 명씩만 사용

[동기화 방법]

1️⃣ synchronized 키워드
public class Counter {
    private int count = 0;
    
    // 메서드 동기화
    public synchronized void increment() {
        count++;
    }
    
    // 블록 동기화 (더 세밀한 제어)
    public void incrementBlock() {
        synchronized (this) {
            count++;
        }
    }
}

2️⃣ volatile 키워드 (가시성 보장)
private volatile boolean flag = true;
// 모든 스레드가 최신 값을 볼 수 있음

3️⃣ Atomic 클래스 (원자적 연산)
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();  // 스레드 안전!

4️⃣ Lock 인터페이스 (더 유연한 제어)
private final Lock lock = new ReentrantLock();

public void increment() {
    lock.lock();
    try {
        count++;
    } finally {
        lock.unlock();  // 반드시 해제!
    }
}

[스레드풀 사용 (권장)]
ExecutorService executor = Executors.newFixedThreadPool(10);

executor.submit(() -> {
    // 작업 수행
});

executor.shutdown();

[실제 경험]
세금계산서 이중 발행 방지:
- DB 레벨: 낙관적 락 + 유니크 제약조건
- 애플리케이션 레벨: synchronized 또는 Redis 분산 락
→ 이중 발행 오류 0건 달성!
```

---

## 🔄 Java Collection Framework

### Q13. Java Collection 구조를 설명해주세요.

### 💡 모범 답변

```
[Collection Framework 계층 구조]

                    Iterable
                       │
                   Collection
                  /    │     \
               List   Set    Queue
               /│\     │\      │
         ArrayList│  HashSet│  LinkedList
         LinkedList  TreeSet  PriorityQueue
         Vector      LinkedHashSet

                     Map (별도)
                    / │ \
             HashMap TreeMap LinkedHashMap
             Hashtable

[각 인터페이스 특징]

┌──────────┬─────────────────────────────────┐
│   List   │ 순서 O, 중복 O, 인덱스 접근      │
├──────────┼─────────────────────────────────┤
│   Set    │ 순서 X, 중복 X, 유일한 값        │
├──────────┼─────────────────────────────────┤
│  Queue   │ FIFO (선입선출)                 │
├──────────┼─────────────────────────────────┤
│   Map    │ Key-Value 쌍, Key 중복 X        │
└──────────┴─────────────────────────────────┘

[재미있는 비유 🎒]
- List: 책장 (순서대로 정리, 같은 책 여러 권 가능)
- Set: 출석부 (중복 없음, 순서 상관없음)
- Queue: 줄 서기 (먼저 온 사람 먼저)
- Map: 사물함 (번호표로 물건 찾기)
```

---

### Q14. ArrayList와 LinkedList의 차이점은?

### 💡 모범 답변

```
[내부 구조]

ArrayList: 배열 기반
┌───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │   │   │
└───┴───┴───┴───┴───┴───┴───┘
  ↑ 연속된 메모리

LinkedList: 노드 연결
┌───┐   ┌───┐   ┌───┐   ┌───┐
│ A │──▶│ B │──▶│ C │──▶│ D │
└───┘   └───┘   └───┘   └───┘
  ↑ 포인터로 연결

[시간 복잡도 비교]

┌────────────┬─────────────┬─────────────┐
│    연산     │  ArrayList  │ LinkedList  │
├────────────┼─────────────┼─────────────┤
│ 인덱스 조회 │   O(1) ⭐   │    O(n)     │
│ 맨 뒤 추가  │   O(1)      │   O(1) ⭐   │
│ 중간 삽입   │   O(n)      │   O(1) ⭐   │
│ 중간 삭제   │   O(n)      │   O(1) ⭐   │
│ 메모리 효율 │   좋음 ⭐   │    나쁨     │
└────────────┴─────────────┴─────────────┘

[재미있는 비유 📚]
- ArrayList: 책꽂이 (중간에 책 꽂으려면 다 밀어야 함)
- LinkedList: 기차 칸 (중간에 칸 추가 쉬움, 찾으려면 앞에서부터)

[사용 가이드]
- 조회가 많음 → ArrayList ⭐ (대부분의 경우)
- 삽입/삭제가 많음 → LinkedList
- 확실하지 않으면 → ArrayList (캐시 효율 좋음)
```

---

### Q15. HashMap과 HashTable의 차이점은?

### 💡 모범 답변

```
[비교 표]

┌────────────────┬────────────┬────────────┐
│      항목       │  HashMap   │ Hashtable  │
├────────────────┼────────────┼────────────┤
│ 동기화         │ ❌ 비동기  │ ✅ 동기화  │
│ null 허용      │ ✅ Key/Value│ ❌ 불가    │
│ 성능           │ 빠름 ⭐    │ 느림       │
│ 도입 버전      │ Java 1.2   │ Java 1.0   │
│ 상속           │ AbstractMap│ Dictionary │
│ 현재 사용      │ ✅ 권장    │ ❌ 레거시  │
└────────────────┴────────────┴────────────┘

[멀티스레드 환경에서 HashMap 사용하려면?]

1️⃣ Collections.synchronizedMap()
Map<String, String> syncMap = 
    Collections.synchronizedMap(new HashMap<>());

2️⃣ ConcurrentHashMap (권장! ⭐)
Map<String, String> concurrentMap = new ConcurrentHashMap<>();
// 세그먼트 단위 락으로 성능 우수

[HashMap 동작 원리]
1. key의 hashCode() 계산
2. 해시값으로 버킷(배열) 위치 결정
3. 충돌 시: LinkedList 또는 Tree(8개 이상)로 저장

┌───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │  ← 버킷 배열
└───┴─│─┴───┴─│─┴───┘
      ↓       ↓
    ┌───┐  ┌───┐
    │K:V│  │K:V│
    └─│─┘  └─│─┘
      ↓       ↓
    ┌───┐  ┌───┐
    │K:V│  │K:V│  ← 충돌 시 체이닝
    └───┘  └───┘
```

---

# 10. 자료구조와 알고리즘

## 📚 기본 자료구조

### Q1. 배열(Array)과 리스트(List)의 차이점은?

### 💡 모범 답변

```
[비교 표]

┌────────────────┬─────────────────┬─────────────────┐
│      항목       │     배열(Array) │   리스트(List)  │
├────────────────┼─────────────────┼─────────────────┤
│ 크기           │ 고정 (생성 시)  │ 가변 (동적)     │
│ 메모리         │ 연속적          │ 불연속 가능     │
│ 접근 속도      │ O(1) ⭐        │ O(1)~O(n)      │
│ 삽입/삭제      │ O(n)           │ O(1)~O(n)      │
│ 타입           │ 기본형 가능     │ 객체만 (Wrapper)│
└────────────────┴─────────────────┴─────────────────┘

[재미있는 비유 🏢]
- 배열: 아파트 동 (호수 고정, 빈 집 있어도 호수 유지)
- 리스트: 대기 줄 (사람 수에 따라 늘었다 줄었다)

[Java 코드]
// 배열: 크기 고정
int[] arr = new int[5];
arr[0] = 1;

// ArrayList: 크기 가변
List<Integer> list = new ArrayList<>();
list.add(1);  // 자동으로 크기 증가

[배열 선택 시나리오]
- 크기가 정해져 있음
- 기본형 데이터 대량 처리 (메모리 효율)
- 인덱스 접근이 대부분

[리스트 선택 시나리오]
- 크기가 가변적
- 삽입/삭제가 빈번
- 다양한 메서드 필요 (contains, indexOf 등)
```

---

### Q2. Stack과 Queue를 설명해주세요.

### 💡 모범 답변

```
[Stack - LIFO (Last In First Out)]

       push →  ┌───┐
               │ D │ ← top (마지막에 넣은 것)
               ├───┤
               │ C │
               ├───┤
               │ B │
               ├───┤
               │ A │
        pop ←  └───┘

[재미있는 비유 📚]
책 더미: 맨 위에 올린 책을 먼저 꺼냄

[Queue - FIFO (First In First Out)]

enqueue →  ┌───┬───┬───┬───┐  → dequeue
           │ A │ B │ C │ D │
           └───┴───┴───┴───┘
          front           rear

[재미있는 비유 🎢]
놀이공원 줄: 먼저 온 사람이 먼저 탑승

[Java 구현]

// Stack
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.pop();    // 2 반환 (LIFO)
stack.peek();   // 1 반환 (제거하지 않고 확인)

// Queue
Queue<Integer> queue = new LinkedList<>();
queue.offer(1);
queue.offer(2);
queue.poll();   // 1 반환 (FIFO)
queue.peek();   // 2 반환 (제거하지 않고 확인)

// Deque (양방향 큐) - Stack/Queue 둘 다 가능!
Deque<Integer> deque = new ArrayDeque<>();
deque.addFirst(1);  // Stack처럼
deque.addLast(2);   // Queue처럼

[사용 사례]
- Stack: 뒤로가기, Undo 기능, 괄호 검사, 재귀 호출
- Queue: 프린터 대기열, BFS 탐색, 작업 스케줄링
```

---

### Q3. Tree 자료구조를 설명해주세요.

### 💡 모범 답변

```
[Tree 기본 용어]

            A          ← 루트(Root)
          / | \
         B  C  D       ← 자식(Child)
        /\     |
       E  F    G       ← 리프(Leaf): 자식이 없는 노드

- 부모(Parent): B의 부모는 A
- 형제(Sibling): B, C, D는 형제
- 깊이(Depth): 루트부터의 거리 (A=0, B=1)
- 높이(Height): 리프까지의 최대 거리

[이진 트리 (Binary Tree)]
각 노드가 최대 2개의 자식을 가짐

        A
       / \
      B   C
     / \   \
    D   E   F

[이진 탐색 트리 (BST: Binary Search Tree)] ⭐
왼쪽 < 부모 < 오른쪽 규칙!

        8
       / \
      3   10
     / \    \
    1   6   14
       / \
      4   7

- 검색/삽입/삭제: O(log n) (균형 잡힌 경우)
- 최악(한쪽으로 치우침): O(n)

[Java 구현]
class Node {
    int value;
    Node left, right;
}

// TreeSet: 정렬된 Set (내부적으로 Red-Black Tree)
TreeSet<Integer> set = new TreeSet<>();
set.add(5); set.add(3); set.add(8);
// 결과: [3, 5, 8] 자동 정렬!

// TreeMap: 정렬된 Map
TreeMap<String, Integer> map = new TreeMap<>();
map.put("banana", 2);
map.put("apple", 1);
// 키가 알파벳 순으로 정렬됨
```

---

### Q4. 해시(Hash)란 무엇인가요?

### 💡 모범 답변

```
[해시란?]
임의의 데이터를 고정된 크기의 값으로 변환하는 함수

"hello" → hashFunction() → 12345 (해시값)

[재미있는 비유 🔐]
- 해시 함수: 믹서기 (재료 넣으면 동일한 결과물)
- 해시값: 지문 (고유한 식별자)

[해시 테이블 구조]

Key → hashFunction() → 인덱스 → 버킷에서 값 찾기

┌───────┐
│ Key:A │ → hash(A) = 2 → bucket[2] → Value
└───────┘

버킷 배열:
┌───┬───┬───┬───┬───┐
│   │   │A:V│   │   │
└───┴───┴───┴───┴───┘
  0   1   2   3   4

[해시 충돌 (Collision)]
서로 다른 키가 같은 해시값을 가질 때

해결 방법:
1️⃣ Chaining (체이닝)
   - 같은 버킷에 LinkedList로 연결
   
2️⃣ Open Addressing (개방 주소법)
   - 다른 빈 버킷을 찾아서 저장

[시간 복잡도]
- 평균: O(1) 삽입/검색/삭제
- 최악: O(n) 모든 키가 충돌할 때

[Java HashMap 동작]
1. key.hashCode() 호출
2. 해시값으로 버킷 인덱스 계산
3. 버킷에 저장 (충돌 시 체이닝)
4. Java 8+: 8개 이상이면 Tree로 변환 (O(log n))

[좋은 해시 함수 조건]
- 충돌 최소화
- 균등 분포
- 빠른 계산
```

---

### Q5. 힙(Heap)과 우선순위 큐를 설명해주세요.

### 💡 모범 답변

```
[힙(Heap)이란?]
완전 이진 트리 + 힙 속성을 만족하는 자료구조

[최소 힙 (Min Heap)]
부모 ≤ 자식 (루트가 최솟값)

        1           ← 최솟값
       / \
      3   2
     / \
    5   4

[최대 힙 (Max Heap)]
부모 ≥ 자식 (루트가 최댓값)

        5           ← 최댓값
       / \
      3   4
     / \
    1   2

[시간 복잡도]
- 삽입: O(log n)
- 삭제(루트): O(log n)
- 최소/최대값 조회: O(1)

[우선순위 큐 (Priority Queue)]
= 힙으로 구현된 큐

// Java에서 사용
PriorityQueue<Integer> minHeap = new PriorityQueue<>();  // 최소 힙
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());  // 최대 힙

minHeap.offer(3);
minHeap.offer(1);
minHeap.offer(2);

minHeap.poll();  // 1 (최솟값부터 나옴)
minHeap.poll();  // 2
minHeap.poll();  // 3

[사용 사례]
- 다익스트라 최단 경로 알고리즘
- 작업 스케줄링 (우선순위 높은 것 먼저)
- 실시간 랭킹 시스템
- 힙 정렬

[재미있는 비유 🏥]
응급실 대기: 위급한 환자(우선순위 높음)가 먼저 치료
```

---

## 🔢 정렬 알고리즘

### Q6. 주요 정렬 알고리즘의 시간 복잡도를 비교해주세요.

### 💡 모범 답변

```
[정렬 알고리즘 비교]

┌────────────┬───────────┬───────────┬───────────┬────────┐
│   알고리즘  │  평균     │  최악     │  공간     │ 안정성 │
├────────────┼───────────┼───────────┼───────────┼────────┤
│ 버블 정렬  │ O(n²)     │ O(n²)     │ O(1)      │ ✅     │
│ 선택 정렬  │ O(n²)     │ O(n²)     │ O(1)      │ ❌     │
│ 삽입 정렬  │ O(n²)     │ O(n²)     │ O(1)      │ ✅     │
│ 퀵 정렬 ⭐ │ O(n log n)│ O(n²)     │ O(log n)  │ ❌     │
│ 병합 정렬  │ O(n log n)│ O(n log n)│ O(n)      │ ✅     │
│ 힙 정렬    │ O(n log n)│ O(n log n)│ O(1)      │ ❌     │
│ 팀 정렬 ⭐ │ O(n log n)│ O(n log n)│ O(n)      │ ✅     │
└────────────┴───────────┴───────────┴───────────┴────────┘

* 안정성: 같은 값의 상대적 순서가 유지되는지

[재미있는 비유로 이해하기 🃏]

1️⃣ 버블 정렬: 무거운 거품이 아래로 가라앉듯
   인접한 두 요소 비교 → 교환 반복

2️⃣ 선택 정렬: 가장 작은 카드 찾아서 앞으로
   최솟값 찾기 → 맨 앞과 교환 반복

3️⃣ 삽입 정렬: 카드 게임처럼 손에 든 패 정렬
   새 카드를 적절한 위치에 삽입

4️⃣ 퀵 정렬 ⭐: 피벗 기준 분할 정복
   피벗보다 작은 것 왼쪽, 큰 것 오른쪽

5️⃣ 병합 정렬: 반으로 나누고 합치면서 정렬
   분할 → 정렬하며 병합

[Java에서 정렬]
Arrays.sort(arr);           // 기본형: Dual-Pivot Quick Sort
Collections.sort(list);     // 객체: Tim Sort (병합+삽입)
```

---

### Q7. 퀵 정렬(Quick Sort)을 설명해주세요.

### 💡 모범 답변

```
[퀵 정렬 원리]
분할 정복(Divide and Conquer) 알고리즘

1. 피벗(기준) 선택
2. 피벗보다 작은 것 → 왼쪽
3. 피벗보다 큰 것 → 오른쪽
4. 재귀적으로 반복

[동작 예시]
[5, 3, 8, 1, 9, 2, 7]  피벗=5

[3, 1, 2] [5] [8, 9, 7]  분할 완료
    ↓           ↓
[1, 2] [3]  [7] [8, 9]   재귀 분할
   ↓           ↓
[1][2]      [8][9]

결과: [1, 2, 3, 5, 7, 8, 9]

[Java 구현]
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIdx = partition(arr, low, high);
        quickSort(arr, low, pivotIdx - 1);   // 왼쪽
        quickSort(arr, pivotIdx + 1, high);  // 오른쪽
    }
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

[시간 복잡도]
- 평균: O(n log n) ⭐
- 최악: O(n²) (이미 정렬된 경우)
- 최악 방지: 랜덤 피벗, 중간값 피벗

[왜 빠른가?]
- In-place 정렬 (추가 메모리 거의 안 씀)
- 캐시 지역성 좋음
- 실제 상수 계수가 작음
```

---

## 🔍 탐색 알고리즘

### Q8. 이진 탐색(Binary Search)을 설명해주세요.

### 💡 모범 답변

```
[이진 탐색이란?]
정렬된 배열에서 절반씩 범위를 줄여가며 탐색

[조건] 배열이 정렬되어 있어야 함!

[동작 예시]
찾는 값: 7

[1, 3, 5, 7, 9, 11, 13]
      ↑ mid=5 (7 > 5) → 오른쪽으로

            [7, 9, 11, 13]
               ↑ mid=9 (7 < 9) → 왼쪽으로

            [7]
             ↑ 찾음!

[시간 복잡도]
- O(log n) ⭐ (매번 절반씩 줄어듦)
- 100만 개 데이터 → 최대 20번 비교!

[Java 구현]
int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 오버플로우 방지
        
        if (arr[mid] == target) {
            return mid;  // 찾음!
        } else if (arr[mid] < target) {
            left = mid + 1;   // 오른쪽 탐색
        } else {
            right = mid - 1;  // 왼쪽 탐색
        }
    }
    return -1;  // 못 찾음
}

// Java 라이브러리 활용
Arrays.binarySearch(arr, target);
Collections.binarySearch(list, target);

[재미있는 비유 📖]
사전에서 단어 찾기:
- 순차 탐색: 1페이지부터 쭉~
- 이진 탐색: 중간 펴고 → 앞/뒤 결정 → 반복

[사용 사례]
- 정렬된 배열에서 값 찾기
- Lower Bound, Upper Bound
- 최적화 문제 (결정 문제로 변환)
```

---

### Q9. BFS와 DFS를 설명해주세요.

### 💡 모범 답변

```
[그래프 탐색 두 가지 방법]

DFS (Depth-First Search): 깊이 우선
BFS (Breadth-First Search): 너비 우선

[예시 그래프]
        A
       / \
      B   C
     /|   |\
    D E   F G

[DFS 탐색 순서]
A → B → D → E → C → F → G (깊이 먼저)

한 우물 파기! 막다른 길 나오면 돌아와서 다른 길

[BFS 탐색 순서]
A → B → C → D → E → F → G (너비 먼저)

한 층씩 탐색! 가까운 곳부터 다 보고 멀리

[구현 비교]

┌────────┬───────────────────────────────────┐
│  DFS   │ Stack 또는 재귀                    │
├────────┼───────────────────────────────────┤
│  BFS   │ Queue                             │
└────────┴───────────────────────────────────┘

// DFS (재귀)
void dfs(Node node, Set<Node> visited) {
    visited.add(node);
    System.out.println(node.value);
    
    for (Node neighbor : node.neighbors) {
        if (!visited.contains(neighbor)) {
            dfs(neighbor, visited);
        }
    }
}

// BFS (큐)
void bfs(Node start) {
    Queue<Node> queue = new LinkedList<>();
    Set<Node> visited = new HashSet<>();
    
    queue.offer(start);
    visited.add(start);
    
    while (!queue.isEmpty()) {
        Node node = queue.poll();
        System.out.println(node.value);
        
        for (Node neighbor : node.neighbors) {
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
}

[사용 사례]
DFS: 미로 탈출, 사이클 감지, 백트래킹
BFS: 최단 경로, 레벨별 탐색, 친구 추천 (몇 다리 건너)

[재미있는 비유 🌳]
- DFS: 한 가지를 끝까지 타고 올라감
- BFS: 나무 높이별로 가지를 모두 확인
```

---

## 📏 시간 복잡도 (Big-O)

### Q10. 시간 복잡도의 개념과 종류를 설명해주세요.

### 💡 모범 답변

```
[시간 복잡도란?]
입력 크기(n)에 따른 알고리즘 실행 시간 증가율

[Big-O 표기법 - 최악의 경우]

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)
 ↑                                              ↑
빠름                                          느림

[시각화]

     실행
     시간
      ↑     O(2ⁿ)
      │    /
      │   / O(n²)
      │  /  /
      │ /  /  O(n log n)
      │/  /  /  O(n)
      │__/__/___________O(log n)
      │___________________O(1)
      └─────────────────→ n (입력 크기)

[각 복잡도 예시]

O(1) - 상수 시간
  arr[0];  // 배열 인덱스 접근
  map.get(key);  // 해시맵 조회

O(log n) - 로그 시간
  이진 탐색
  균형 트리 탐색

O(n) - 선형 시간
  for (int i = 0; i < n; i++)  // 단순 반복

O(n log n)
  퀵 정렬, 병합 정렬

O(n²) - 이차 시간
  for (i) { for (j) { } }  // 이중 반복
  버블 정렬

O(2ⁿ) - 지수 시간
  피보나치 (재귀, 메모이제이션 없이)
  부분집합 생성

[실제 시간 예시 (n = 1,000,000)]
O(1): 1번 연산
O(log n): 약 20번
O(n): 1,000,000번
O(n log n): 20,000,000번
O(n²): 1,000,000,000,000번 😱

[실무 팁]
- 1초에 약 1억 번 연산 가능
- n = 10,000 이상이면 O(n²)는 위험
- 정렬 → O(n log n) 알고리즘 사용
```

---

## 📝 면접 최종 체크리스트 (추가)

### Java 필수 암기

- [ ] JVM 메모리 구조 (Heap, Stack, Method Area)
- [ ] GC 동작 원리 (Young/Old Generation)
- [ ] == vs equals() 차이
- [ ] String vs StringBuilder vs StringBuffer
- [ ] 추상 클래스 vs 인터페이스
- [ ] Checked vs Unchecked Exception
- [ ] Collection Framework 구조
- [ ] ArrayList vs LinkedList
- [ ] HashMap 동작 원리

### 자료구조/알고리즘 필수 암기

- [ ] Stack (LIFO) vs Queue (FIFO)
- [ ] 이진 탐색 트리 특징
- [ ] 해시 테이블과 충돌 해결
- [ ] 힙과 우선순위 큐
- [ ] 퀵 정렬 O(n log n)
- [ ] 이진 탐색 O(log n)
- [ ] BFS (Queue) vs DFS (Stack/재귀)
- [ ] Big-O 표기법

---

**화이팅! 🎯 민야령 님의 성공적인 면접을 응원합니다!**

